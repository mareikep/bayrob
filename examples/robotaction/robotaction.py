import datetime
import os
from random import randint

import pandas as pd
from matplotlib import pyplot as plt

from calo.models.action import Move
from calo.models.world import Agent, Grid
from calo.utils import locs
from calo.utils.constants import FILESTRFMT
from jpt import infer_from_dataframe, JPT


def robot_pos_random(dt):

    # write sample data for MOVEFORWARD and TURN action of robot (absolute positions)
    for j in range(100):
        poses = []  # for plotting
        turns = []

        # init agent and world
        a = Agent([0, 0], [1, 0])
        w = Grid()
        w.obstacle(25, 25, 50, 50)
        w.obstacle(-10, 10, 0, 40)
        w.obstacle(50, -30, 20, 10)
        w.obstacle(-75, -10, -50, -40)
        w.obstacle(-25, -50, -15, -75)
        a.world = w

        for action in range(100):
            deg = randint(-180, 180)
            turns.append(a.dir + (deg,))
            Move.turndeg(a, deg)

            steps = randint(1, 10)
            poses.append(a.pos + a.dir + (steps, a.collided))
            Move.moveforward(a, steps)

        poses.append(a.pos + a.dir + (0, a.collided))
        turns.append(a.dir + (0,))

        df_moveforward = pd.DataFrame(poses, columns=['x', 'y', 'xdir', 'ydir', 'numsteps', 'collided'])
        df_moveforward.to_csv(os.path.join(locs.logs, f'{dt}-{j}-MOVEFORWARD.csv'), index=False)

        df_turn = pd.DataFrame(turns, columns=['xdir', 'ydir', 'angle'])
        df_turn.to_csv(os.path.join(locs.logs, f'{dt}-{j}-TURN.csv'), index=False)

        plt.scatter(df_moveforward['x'], df_moveforward['y'], marker='*', c='cornflowerblue')
        plt.plot(df_moveforward['x'], df_moveforward['y'], c='cornflowerblue')
        plt.scatter(df_moveforward['x'].iloc[0], df_moveforward['y'].iloc[0], marker='o', c='green', label='Start')
        plt.scatter(df_moveforward['x'].iloc[-1], df_moveforward['y'].iloc[-1], marker='o', c='red', label='End')
        plt.savefig(os.path.join(locs.logs, f'{dt}-{j}-MOVE.png'))

    plt.grid()
    plt.legend()
    plt.show()


def data_curation(dt):
    # read position data files generated by test_robot_pos and generate large file containing deltas (position-independent)
    # data_moveforward = pd.DataFrame(columns=['deltax', 'deltay', 'xdir', 'ydir', 'numsteps'])
    data_moveforward = pd.DataFrame(columns=['x', 'y', 'xnext', 'ynext', 'numsteps'])
    for i in range(100):
        with open(os.path.join(locs.logs, f'{dt}-{i}-{"MOVEFORWARD"}.csv'), 'r') as f:
            d = pd.read_csv(f, delimiter=',', header=0)
            for idx, row in d.iterrows():
                if idx == d.index.max(): break
                # data_moveforward.loc[idx+i*100] = [d.iloc[idx+1]['x']-row['x'], d.iloc[idx+1]['y']-row['y'], row['xdir'], row['ydir'], row['numsteps']]
                data_moveforward.loc[idx + i * 100] = [row['x'], row['y'], d.iloc[idx + 1]['x'], d.iloc[idx + 1]['y'], row['numsteps']]
    data_moveforward.to_csv(os.path.join(locs.logs, f'{dt}-{"ALL"}-{"MOVEFORWARD"}.csv'),
                            index=False)

    # data_turn = pd.DataFrame(columns=['deltaxdir', 'deltaydir', 'angle'])
    data_turn = pd.DataFrame(columns=['xdir', 'ydir', 'xdirnext', 'ydirnext', 'angle'])
    for i in range(100):
        with open(os.path.join(locs.logs, f'{dt}-{i}-{"TURN"}.csv'), 'r') as f:
            d = pd.read_csv(f, delimiter=',', header=0)
            for idx, row in d.iterrows():
                if idx == d.index.max(): continue
                # deltaxdir and deltaydir are differences of two consecutive directions, normalized
                # deltaxdir, deltaydir = d.iloc[idx+1]['xdir']-row['xdir'], d.iloc[idx+1]['ydir']-row['ydir']
                # normfactor = (np.linalg.norm([deltaxdir, deltaydir]) or 1.)
                # if normfactor is 0, the direction does not point in any particular direction, set to 1 to
                # avoid division by 0 [semantically valid as no movement will not cause a delta in direction]
                # data_turn.loc[idx+i*100] = [deltaxdir / normfactor, deltaydir / normfactor, row['angle']]

                # store data of two consecuting steps
                data_turn.loc[idx + i * 100] = [row['xdir'], row['ydir'], d.iloc[idx + 1]['xdir'], d.iloc[idx + 1]['ydir'], row['angle']]
    data_turn.to_csv(os.path.join(locs.logs, f'{dt}-{"ALL"}-{"TURN"}.csv'), index=False)


def jpt_moveforward(dt):
    # learn discriminative JPT from data generated by test_data_curation for MOVEFORWARD
    data_moveforward = pd.read_csv(os.path.join(locs.logs, f'{dt}-ALL-MOVEFORWARD.csv'),
                                   delimiter=',', header=0)
    movevars = infer_from_dataframe(data_moveforward)
    jpt_moveforward = JPT(variables=movevars, targets=movevars[2:4], min_samples_leaf=.02)
    jpt_moveforward.learn(columns=data_moveforward.values.T)
    jpt_moveforward.plot(title='MOVEFORWARD', plotvars=movevars,
                         filename=f'{dt}-ALL-MOVEFORWARD', directory=locs.logs)
    jpt_moveforward.save(os.path.join(locs.logs, f'{dt}-ALL-MOVEFORWARD.tree'))


def jpt_turn(dt):
    # learn discriminative JPT from data generated by test_data_curation for TURN
    data_turn = pd.read_csv(os.path.join(locs.logs, f'{dt}-ALL-TURN.csv'), delimiter=',', header=0)
    turnvars = infer_from_dataframe(data_turn)
    jpt_turn = JPT(variables=turnvars, targets=turnvars[2:4], min_samples_leaf=.02)
    jpt_turn.learn(columns=data_turn.values.T)
    jpt_turn.plot(title='TURN', plotvars=turnvars, filename=f'{dt}-ALL-TURN', directory=locs.logs)
    jpt_turn.save(os.path.join(locs.logs, f'{dt}-ALL-TURN.tree'))
    
    
if __name__ == '__main__':
    DT = f'{datetime.datetime.now().strftime(FILESTRFMT)}'

    robot_pos_random(DT)
    data_curation(DT)
    jpt_moveforward(DT)
    jpt_turn(DT)
    