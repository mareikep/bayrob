import argparse
import mimetypes
import os
import shutil
import tempfile
import traceback
from collections import OrderedDict
from functools import wraps
from pathlib import Path
from typing import Callable, List

import dnutils
import numpy as np
import pandas as pd
import plotly.graph_objects as go

import pyrap
from bayrob import config
from bayrob.core.astar_jpt import Goal
from bayrob.core.base import Query, Search
from bayrob.logs.logs import init_loggers
from bayrob.utils import locs
from bayrob.utils.constants import bayroblogger, bayrobjsonlogger, obstacles, obstacle_kitchen_boundaries, querypresets, \
    searchpresets
from bayrob.utils.plotlib import build_constraints, fig_to_file, plot_heatmap, plot_data_subset, plot_path, \
    plot_pos, plot_dir, gendata
from bayrob.utils.utils import res, urlable, fmt
from bayrob.web.thread import BayRoBSessionThread
from jpt.base.intervals.contset import ContinuousSet
from jpt.distributions.univariate import Bool, Numeric
from pyrap import session
from pyrap.dialogs import options_list
from pyrap.layout import RowLayout, ColumnLayout, CellLayout, StackLayout
from pyrap.ptypes import Color, Image, Pixels, px
from pyrap.pwt.svg.svg import SVG
from pyrap.widgets import Shell, Composite, Label, Button, Separator, TabFolder, Browser, Combo, Edit, Group, Link, \
    SashMenuComposite, ScrolledComposite, Option

if config.getboolean('bayrob', 'smoothed', fallback=False):
    pass
else:
    pass

logger = dnutils.getlogger(bayroblogger)
jsonlogger = dnutils.getlogger(bayrobjsonlogger)


class BayRoBWeb:
    def __init__(self):
        self.bayrob = BayRoBSessionThread(self)
        self.bayrob.adddatapath([os.path.join(locs.examples, 'demo', d) for d in os.listdir(os.path.join(locs.examples, 'demo'))])
        self.wnd_query_model = None
        self.wnd_search = None
        self.qo = Query()
        self.asr = Search()
        self.uploaddir = None
        self.menu_width = 250
        self.wnd_wait = None
        self.wait_imgsize = 85
        self.wait_padding = 30
        self.lbl_status = None

    @staticmethod
    def setup(application) -> None:
        """
        Loads ontology into webapp. For later use

        :param application:     The current application
        :return:                nothing
        """
        BayRoBWeb.compiledoku()

    @staticmethod
    def compiledoku() -> None:
        """
        Compiles the documentation for this software in html, such that the most recent version is available in the
        documentation tab (browser)
        
        :return:
        """
        logger.info("Compiling documentation...")
        if config.get('bayrob', 'mode', fallback='release') != 'debug':
            cmd = f"jupyter-book build {locs.doc} --toc {os.path.join(locs.doc, '_toc.yml')} --path-output {locs.doc} --config {os.path.join(locs.doc, '_config.yml')} -q"
            if config.getboolean('upload', 'typstdoku', fallback=False):
                cmd = f"just --justfile {os.path.join(locs.doct, 'justfile')} --working-directory {locs.doct} compile"
            try:
                logger.debug("Running", cmd)
                os.system(cmd)
            except OSError as e:
                logger.error(f"Could not compile doku: {e}")

    @staticmethod
    def setupdoku() -> None:
        """
        Registers all the files generated by `compiledoku()` to make them available in the browser.
        
        :return:
        """
        l = locs.doct if config.getboolean('upload', 'typstdoku', fallback=False) else locs.doc
        for root, _, files in os.walk(l):
            for f in files:
                if any([f.endswith(ext) for ext in ['.swp', '.inv', '.map']]) or not os.path.splitext(f)[1]: continue
                fname = os.path.join(root.lstrip(l), f)
                try:
                    with open(os.path.join(root, f), 'rb') as fi:
                        session.runtime.mngr.resources.registerf(fname, mimetypes.guess_type(fname)[0], fi, force=True)
                except UnicodeDecodeError:
                    logger.error('Could not register file', fname, '. unicodeerror')

    def checkthread(self, f) -> Callable:
        @wraps(f)
        def decorated(*args, **kwargs):
            if self.bayrob.is_alive():
                self.bayrob.join()
            self.bayrob = BayRoBSessionThread(self)
            self.bayrob.adddatapath([os.path.join(locs.examples, 'demo', d) for d in os.listdir(os.path.join(locs.examples, 'demo'))])
            return f(*args, **kwargs)
        return decorated

    def initialize(self) -> None:
        """
        Set up important configurations for the session such as the default upload folder.

        :return:
        """
        ufldr = config.get('upload', 'uploadfldr', fallback=tempfile.gettempdir())

        if not os.path.exists(ufldr):
            os.mkdir(ufldr)

        dirname = tempfile.mkdtemp(prefix='bayrob', dir=ufldr)
        self.uploaddir = os.path.join(ufldr, dirname)
        logger.debug('Setting upload folder to', self.uploaddir)

        def cleanup(*_):
            if os.path.exists(os.path.join(ufldr, dirname)):
                shutil.rmtree(os.path.join(ufldr, dirname))

        session.on_kill += cleanup

    def presets(
            self,
            qtype,
            model: str = None
    ):
        if qtype == 'queryjpt':
            return querypresets
        elif qtype == 'search':
            return searchpresets
        elif qtype == "queryvars":
            return {
                'perception': {
                    f'x_in x y_in': [self.bayrob.models["perception"].varnames["x_in"],
                                     self.bayrob.models["perception"].varnames["y_in"]],
                    f'xdir_in x ydir_in': [self.bayrob.models["perception"].varnames["xdir_in"],
                                           self.bayrob.models["perception"].varnames["ydir_in"]],
                    **{
                        k: v for k, v in self.bayrob.models['perception'].varnames.items() if
                        k not in ['x_in', 'y_in', 'xdir_in', 'ydir_in']
                    }
                },
                'move': {
                    f'x_in x y_in': [self.bayrob.models["move"].varnames["x_in"],
                                     self.bayrob.models["move"].varnames["y_in"]],
                    f'xdir_in x ydir_in': [self.bayrob.models["move"].varnames["xdir_in"],
                                           self.bayrob.models["move"].varnames["ydir_in"]],
                    f'x_out x y_out': [self.bayrob.models["move"].varnames["x_in"],
                                       self.bayrob.models["move"].varnames["y_in"]],
                    **{
                        k: v for k, v in self.bayrob.models['move'].varnames.items() if
                        k not in ['x_in', 'y_in', 'xdir_in', 'ydir_in', 'x_out', 'y_out']
                    }
                },
                'turn': {
                    f'xdir_in x ydir_in': [self.bayrob.models["turn"].varnames["xdir_in"],
                                           self.bayrob.models["turn"].varnames["ydir_in"]],
                    f'xdir_out x ydir_out': [self.bayrob.models["turn"].varnames["xdir_out"],
                                             self.bayrob.models["turn"].varnames["ydir_out"]],
                    **{
                        k: v for k, v in self.bayrob.models['turn'].varnames.items() if
                        k not in ['xdir_in', 'ydir_in', 'xdir_out', 'ydir_out']
                    }
                },
                'pr2': {
                    f't_x x t_y': [self.bayrob.models["pr2"].varnames["t_x"],
                                   self.bayrob.models["pr2"].varnames["t_y"]],
                    **{
                        k: v for k, v in self.bayrob.models['pr2'].varnames.items() if
                        k not in ['t_x', 't_y', 't_z', 'duration', 'angle_z']
                    }
                },
                'alarm': {
                    k: v for k, v in self.bayrob.models['alarm'].varnames.items()
                }
            }
        else:
            return {}

    def suggestions(
            self,
            var,
            mean=False,
            tolerance=False
    ):
        # return string of value suggestions for variable selection in query model window
        if var.domain is Numeric:
            if mean:
                return "mean value, e.g. 3"
            elif tolerance:
                return "variance, e.g. 0.01"
            else:
                return "range/interval, e.g. [3, 50] or [10, 20["
        if var.domain is Bool:
            return "anything Boolean-like, e.g. True, true, y, yes, 1, ..."
        else:
            return f"comma-separated, e.g. {', '.join(list(var.domain.values)[:5])}"

    def parseval(
            self,
            val,
            var=None,
            onlysets=False
    ):
        # transform entered values into valid query values for that type of variable (both query model and search)
        try:
            logger.error(f"parsing val {var.domain}, {val}")
            if var.domain is Numeric:
                try:
                    val_ = ContinuousSet.fromstring(val)
                except:
                    val_ = float(val)
                return val_
            elif var.domain is Bool:
                if onlysets:
                    return set(map(lambda x: x.strip().lower() in ['true', '1', 't', 'y', 'yes', 'yeah', 'yup', 'certainly', 'uh-huh'], val.split(',')))
                return val.strip().lower() in ['true', '1', 't', 'y', 'yes', 'yeah', 'yup', 'certainly', 'uh-huh']
            else:
                return set(map(lambda x: x.strip(), val.split(',')))
        except:
            return val

    def plot_ground_truth(
            self,
            df,
            limx,
            limy,
            plot,
            plottype,
            pdfvars
    ):
        # return plot of ground truth (bar chart or scatter plot)
        gt = go.Figure()

        gt_ = plot_data_subset(
            df,
            xvar=plot[0].name if isinstance(plot, list) and len(plot) > 1 else plot.name,
            yvar=plot[1].name if isinstance(plot, list) and len(plot) > 1 else None,
            constraints=pdfvars,
            limx=limx,
            limy=limy,
            save=None,
            show=False,
            color='rgb(0,104,180)',
            plot_type=plottype
        )
        if gt_ is not None:
            gt.layout = gt_.layout
            gt.add_traces(gt_.data)

        return gt

    def plot_dist_heatmap(
            self,
            data,
            limx,
            limy
    ):
        # return plot of distribution (heatmap)
        dist = go.Figure()

        # plot heatmap
        dist_ = plot_heatmap(
            xvar='x',
            yvar='y',
            data=data,
            limx=limx,
            limy=limy,
            # limz=(0, 1),
            show=False,
            save=None,
            fun="heatmap"
        )

        if dist_ is not None:
            dist.layout = dist_.layout
            dist.add_traces(dist_.data)

        return dist

    def plot_dist_bar(
            self,
            posterior,
            plot
    ):
        # return plot of distribution (bar chart)
        plot_ = posterior[plot].plot(
            engine="plotly",
            view=False,
            title=False,  # f'Dist: {plot}<br>(Query): {querystring}',
            alphabet=True,
            color='rgb(59, 41, 106)',
            xvar=plot.name
        )
        return plot_

    def gendata_path(
            self,
            xvar: str,
            yvar: str,
            path: List
    ):
        # generate data for path plot (result of search)
        d = [
            (
                np.mean([s[xvar].mpe()[0].lower, s[xvar].mpe()[0].upper]),  # x
                np.mean([s[yvar].mpe()[0].lower, s[yvar].mpe()[0].upper]),  # y
                np.mean([s['xdir_in'].mpe()[0].lower, s['xdir_in'].mpe()[0].upper]),  # dx
                np.mean([s['ydir_in'].mpe()[0].lower, s['ydir_in'].mpe()[0].upper]),  # dy
                f'Step {i}',  # step
                f'<b>Step {i}</b><br>'
                f'<b>{"ROOT" if s.leaf is None or s.tree is None else f"{s.tree}-Leaf#{s.leaf}"}</b><br>'
                f'<b>MPEs:</b><br>'
                f'{"<br>".join(f"<i>{k}:</i> {fmt(v)}" for k, v in s.items())}<br>'
                f'<b>Expectations:</b><br>'
                f'{"<br>".join(f"<i>{k}:</i> {fmt(v.expectation())}" for k, v in s.items())}<br>',
                1  # size
            )
            for i, s in enumerate(path) if not isinstance(s, Goal)
        ]

        return d

    def wait_bounds(self, w, h):
        return w - self.wait_imgsize - self.wait_padding, h - self.wait_imgsize - self.wait_padding, self.wait_imgsize, self.wait_imgsize

    def cancel_bayrob(self):
        self.bayrob.kill()

    def run_bayrob(self, query, callback, runf) -> None:
        # use bayrob reasoner to query single model
        self.bayrob.pushsession.start()
        self.bayrob.query = query

        self.bayrob.runfunction = runf
        self.bayrob.callback = callback
        w = session.runtime.display.width.value
        h = session.runtime.display.height.value
        self.wnd_wait.bounds = self.wait_bounds(w, h)
        self.wnd_wait.visible = True
        self.bayrob.start()

    # = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
    # DESKTOP VERSION
    # = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
    def desktop(self, **kwargs) -> None:
        self.initialize()
        with open(res('static/css/other.css')) as fcss:
            session.runtime.requirecss(fcss)

        self._shell = Shell(maximized=True, titlebar=False)
        self._shell.bg = Color('transp')
        self._shell.on_resize += self._shell.dolayout

        comp_mainframe = Composite(self._shell.content)
        comp_mainframe.layout = RowLayout(halign='fill', valign='fill', flexrows={1: 1}, vspace=0)

        # * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        # HEADER
        # * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        comp_header = Composite(comp_mainframe)
        comp_header.layout = ColumnLayout(halign='fill', minheight=px(60), flexcols=1)
        # comp_header.css = 'navbar'
        comp_header.bgimg = Image(res('static/images/dark-metal-texture_rot.png'))

        # LOGOS #
        _logo = Image(res('static/images/logo.png')).resize(height=Pixels(55))
        logo = Label(comp_header, padding=px(0), img=_logo, valign='center')
        logo.bg = Color('transp')
        Label(comp_header)
        easelogo = Label(comp_header, img=Image(res('static/images/open-ease-logo.png')).resize(height=Pixels(40)), valign='center', halign='center')
        easelogo.bg = Color('transp')
        ailogo = Label(comp_header, img=Image(res('static/images/ai_logo_white.png')).resize(height=Pixels(40)), valign='center', halign='center')
        ailogo.bg = Color('transp')
        unilogo = Label(comp_header, img=Image(res('static/images/uni-bremen.png')).resize(height=Pixels(40)), valign='center', halign='center')
        unilogo.bg = Color('transp')

        # * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        # WAIT LOGO
        # * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

        # initialize wait logo but hide it so it can be shown/hidden when query is running/finished
        self.wnd_wait = Shell(parent=self._shell, titlebar=False, border=False, resize=False, modal=False, halign='right', valign='bottom')
        self.wnd_wait.create_content()
        self.wnd_wait.bg = Color('transp')
        self.wnd_wait.content.bg = Color('transp')

        w = session.runtime.display.width.value
        h = session.runtime.display.height.value
        self.wnd_wait.bounds = self.wait_bounds(w, h)

        lbl_wnd = Label(self.wnd_wait.content, img=Image(res('static/images/wait_steelblue.gif')), valign='fill', halign='fill')
        lbl_wnd.bg = Color('transp')

        def movewait() -> None:
            w = session.runtime.display.width.value
            h = session.runtime.display.height.value
            self.wnd_wait.bounds = self.wait_bounds(w, h)

        self.wnd_wait.on_resize += self.wnd_wait.dolayout
        self._shell.on_resize += movewait
        self.wnd_wait.show()
        self.wnd_wait.visible = False

        # * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        # TABFOLDER
        # * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        tabfldr_body = TabFolder(comp_mainframe, tabpos='bottom', halign='fill', valign='fill')

        Separator(comp_mainframe, horizontal=True, halign='fill')

        comp_status = Composite(comp_mainframe, text='Status')
        comp_status.layout = ColumnLayout(halign='fill', valign='fill', flexcols=1)

        Label(comp_status, text='Status:', halign='fill', valign='fill')
        self.lbl_status = Edit(comp_status, text='OK', multiline=True, halign='fill', valign='fill', border=False, minheight=20)
        Link(comp_status, text="<a href='http://ai.uni-bremen.de/doku.php?id=impressum' target='_blank'>Disclaimer</a>", markup=True, padding=5, halign='fill', valign='fill')

        # BAYROB TAB #
        da_stack = tabfldr_body.addtab('BayRoB', idx=2)
        da_stack.content.layout = StackLayout(halign='fill', valign='fill')

        # * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        # BAYROB MENU
        # * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        da_sash_menu = SashMenuComposite(da_stack.content, self._shell, color='#5882B5', mwidth=self.menu_width)
        da_comp_menu = da_sash_menu.menu
        # da_comp_menu.css = 'menu'
        da_comp_menu.layout.flexrows = {2: 1}
        da_sash_menu.togglemenu()

        btn_query_model = Button(da_comp_menu, text='Query model', minwidth=px(self.menu_width - 50), halign='fill', valign='fill')
        btn_search = Button(da_comp_menu, text='Search', minwidth=px(self.menu_width - 50), halign='fill', valign='fill')

        Label(da_comp_menu, text='', valign='fill', halign='fill')
        Separator(da_comp_menu, horizontal=True, halign='fill')

        btn_download = Button(da_comp_menu, text='Download', halign='fill', valign='fill', minwidth=px(self.menu_width - 50))
        btn_download.enabled = False
        btn_clearviz = Button(da_comp_menu, text='Clear', halign='fill', valign='fill', minwidth=px(self.menu_width - 50))

        # for b in (btn_query_model, btn_search, btn_download, btn_clearviz):
        #     b.css = 'menu'

        # * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        # BAYROB
        # * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        comp_analysis = Composite(da_sash_menu.content)
        comp_analysis.layout = ColumnLayout(flexcols={0: 2, 2: 1}, halign='fill', valign='fill', padding_left=15)

        grp_analysisviz = Group(comp_analysis, 'Visualization')
        grp_analysisviz.layout = RowLayout(halign='fill', valign='fill', flexrows=0, padding_left=12)
        comp_analysisviz = Composite(grp_analysisviz)
        comp_analysisviz.layout = CellLayout(halign='fill', valign='fill', padding_top=10)
        bglogo = Label(comp_analysisviz, img=Image(res('static/images/logo.png')).resize(height=Pixels(150)), valign='center', halign='center')

        Separator(comp_analysis, horizontal=True, halign='fill')

        comp_analysistext = Group(comp_analysis, 'Results')
        comp_analysistext.layout = ColumnLayout(halign='fill', valign='fill', flexcols=0, padding_left=12)
        lbl_textresults = Edit(comp_analysistext, text='', multiline=True, border=False, halign='fill', valign='fill')
        # lbl_textresults.css = 'myscroll'

        def clear(*_) -> None:
            # clear previously loaded visualizations
            for c in comp_analysisviz.children:
                c.dispose()

            bglogo = Label(comp_analysisviz, img=Image(res('static/images/logo.png')).resize(height=Pixels(150)), valign='center', halign='center')

            # clear text results
            lbl_textresults.text = ''
            self._shell.dolayout()

        def download_visualization(*_) -> None:
            # download pdf of conditional tree generated by query model call

            fn_tree_dists = os.path.join(self.uploaddir, f"conditional_tree_dists.pdf")
            if not os.path.isfile(fn_tree_dists):
                from svglib.svglib import svg2rlg
                from reportlab.graphics import renderPDF

                drawing = svg2rlg(fn_tree_dists.replace(".pdf", ".svg"))
                renderPDF.drawToFile(drawing, fn_tree_dists)

            try:
                if os.path.isfile(fn_tree_dists):
                    logger.debug('Downloading existing file', fn_tree_dists)
                    session.runtime.download(fn_tree_dists, 'application/pdf')
                else:
                    self.lbl_status.text = 'No visualization available for download.'
            except:
                traceback.print_exc()
                session.runtime.download(fn_tree_dists, 'application/pdf', force=True)

        btn_clearviz.on_select += clear
        btn_download.on_select += download_visualization

        # DOCUMENTATION TAB #
        comp_docs = tabfldr_body.addtab('Documentation', idx=2)
        comp_docs.layout = CellLayout(halign='fill', valign='fill')

        comp_ = Composite(comp_docs.content)
        comp_.layout = CellLayout(halign='fill', valign='fill')

        self.setupdoku()
        Browser(comp_, url=config.get('upload', 'dokuloc', fallback=''.join(['http://', session.host, session.location, session.runtime.mngr.resources.get('index.html' if config.getboolean('upload', 'typstdoku', fallback=False) else '_build/html/index.html').location])), halign='fill', valign='fill')

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

        def plot_search_results(*_) -> None:
            # a succeeded search is visualized in terms of a) a plot of the found path, b) an (animated) plot of the
            # position distribution and c) an (animated) plot of the direction distribution

            self.wnd_wait.visible = False
            btn_search.enabled = True
            btn_query_model.enabled = True

            result = self.bayrob.result
            path = result.result

            if not result.success:
                logger.warning(f'There was a problem: Error: {result.error}. Message: {result.message}')
                self.lbl_status.text = "Success!" if self.bayrob.result.success else f"Failed: {result.error}"
                lbl_textresults.text = result.message
                self.bayrob.result.clear()
                self._shell.dolayout()
                return
            else:
                logger.info(f'Search {self.bayrob.query} finished successfully.')

            # create containers for search path visualization
            for c in comp_analysisviz.children:
                c.dispose()

            comp_viz_search = Composite(comp_analysisviz)
            comp_viz_search.layout = ColumnLayout(halign='fill', valign='fill', flexcols=0)

            comp_viz_path = Composite(comp_viz_search)
            comp_viz_path.layout = CellLayout(halign='fill', valign='fill')

            d = self.gendata_path(
                xvar='x_in',
                yvar='y_in',
                path=path
            )

            fig_path = plot_path(
                xvar='x_in',
                yvar='y_in',
                p=path,
                d=d,
                obstacles=[obstacle_kitchen_boundaries] + obstacles,
                show=False
            )

            data_pos = [
                gendata(
                    'x_in',
                    'y_in',
                    s,
                    {},
                ) for i, s in enumerate(path) if not isinstance(s, Goal)
            ]

            fig_pos = plot_pos(
                path=path,
                d=data_pos,
                limx=(0, 100),
                limy=(0, 100),
                show=False
            )

            data_dir = [
                gendata(
                    'xdir_in',
                    'ydir_in',
                    s,
                    {},
                ) for i, s in enumerate(path) if not isinstance(s, Goal)
            ]

            fig_dir = plot_dir(
                path=path,
                d=data_dir,
                limx=(-3, 3),
                limy=(-3, 3),
                show=False
            )

            # save plot to html file
            fname_path = os.path.join(self.uploaddir, f"search-path.html")
            fname_pos = os.path.join(self.uploaddir, f"search-pos.html")
            fname_dir = os.path.join(self.uploaddir, f"search-dir.html")

            fig_to_file(fig_path, fname_path, ftypes=['.svg', '.html'])
            fig_to_file(fig_pos, fname_pos, ftypes=['.svg', '.html'])
            fig_to_file(fig_dir, fname_dir, ftypes=['.svg', '.html'])

            # display plot in visualization
            resname = f'resource/static/image/{Path(fname_path).stem}.html'
            with open(fname_path, 'rb') as f:
                res = session.runtime.mngr.resources.registerf(resname, 'text/html', f, force=True)
                u_ = f'http://{session.host}{session.location}{res.location}'

                Browser(
                    comp_viz_path,
                    url=u_,
                    halign='fill',
                    valign='fill'
                )

            # register file to make it available as resource
            for fn, t in zip([fname_pos, fname_dir], ["Position", "Direction"]):
                resname = f'resource/static/image/{Path(fn).stem}.html'
                with open(fn, 'rb') as f:
                    res = session.runtime.mngr.resources.registerf(resname, 'text/html', f, force=True)
                    u_ = f'http://{session.host}{session.location}{res.location}'

                    # display plot in separate windows
                    open_plot_window_single(u_, t)

            self.lbl_status.text = "Success!" if self.bayrob.result.success else "Failed!"
            lbl_textresults.text = str(self.bayrob.result)

            self.bayrob.result.clear()
            self._shell.dolayout()

        def plot_query_results(*_) -> None:
            # a succeeded query is visualized in terms of a) a plot of ground truth (scatter or normalized bar plot)
            # and b) a plot of the distribution (heatmap or normalized bar plot) for each plot variable enterd in the
            # query window and c) a tree plot of the conditional tree (without distribution images). A new window is
            # opened for each ground truth/distribution plot pair. The conditional tree can be downloaded as PDF file
            # (including distribution images)

            self.wnd_wait.visible = False
            btn_search.enabled = True
            btn_query_model.enabled = True

            result = self.bayrob.result
            cond, post = result.result

            if not result.success:
                logger.warning(f'There was a problem: Error: {result.error}. Message: {result.message}')
                self.lbl_status.text = f"Failed: {result.error}"
                lbl_textresults.text = result.message
                self.bayrob.result.clear()
                self._shell.dolayout()
                return
            else:
                self.lbl_status.text = f"Success! Plotting... {result.message}"
                lbl_textresults.text = result.message if result.message is not None else ""
                logger.info(f'Querying {self.bayrob.query} finished successfully.')
                self._shell.dolayout()

            if self.bayrob.query.plot_tree:
                # plot conditional tree
                fn_tree = os.path.join(self.uploaddir, f"conditional_tree.svg")
                cond.plot(
                    plotvars=None,
                    filename=f'conditional_tree',
                    directory=self.uploaddir,
                    leaffill='#CCDAFF',
                    nodefill='#768ABE',
                    alphabet=True,
                    view=False
                )

                cond.plot(
                    plotvars=list(cond.variables),
                    filename=f'conditional_tree_dists',
                    directory=self.uploaddir,
                    leaffill='#CCDAFF',
                    nodefill='#768ABE',
                    alphabet=True,
                    view=False
                )

                # plot conditional tree and visualize it in main window (downloadable through download button in menu)
                for c in comp_analysisviz.children:
                    c.dispose()

                c = ScrolledComposite(comp_analysisviz, valign='fill', halign='fill', hscroll=True, vscroll=True)
                s = SVG(c.content, svg=fn_tree, halign='fill', valign='fill')
                s.maxheight(comp_analysisviz.bounds[3])
                s.maxwidth(comp_analysisviz.bounds[2])

                btn_download.enabled = True

            # plot ground truth/distribution pairs (separate window for each variable)
            df = pd.read_parquet(self.bayrob.datasets[self.qo.modelname])

            for plot in self.qo.queryvars:
                if isinstance(plot, list):
                    logger.debug(f"Generating numeric/scatter plot")
                    if all([v.name.endswith('_in') for v in plot]):
                        limx = (0, 100)
                        limy = (0, 100)
                    else:
                        if self.bayrob.query.modelname == 'pr2':
                            limx = (-3, 1)
                            limy = (-1.5, .5)
                        else:
                            limx = (-2, 2)
                            limy = (-2, 2)

                    # data generation for distribution plot
                    x = np.linspace(*limx, max(50, int((limx[1] - limx[0]) * 2)))
                    y = np.linspace(*limy, max(50, int((limy[1] - limy[0]) * 2)))

                    X, Y = np.meshgrid(x, y)
                    Z = np.array([cond.pdf(cond.bind({plot[0]: x, plot[1]: y})) for x, y, in zip(X.ravel(), Y.ravel())]).reshape(X.shape)
                    lbl = np.full(Z.shape, '<br>'.join([f'{vname}: {val}' for vname, val in self.qo.evidence.items()]))

                    data = pd.DataFrame(
                        data=[[x, y, Z, lbl]],
                        columns=['x', 'y', 'z', 'lbl']
                    )

                    gt = self.plot_ground_truth(df, limx, limy, plot, 'scatter', {k.name: v for k, v in self.qo.evidence.items()})
                    dist = self.plot_dist_heatmap(data, limx, limy)
                else:
                    logger.debug(f"Generating multinomial/histogram plot")
                    gt = self.plot_ground_truth(df, None, (0, 1), plot, 'histogram', {k.name: v for k, v in self.qo.evidence.items()})
                    dist = self.plot_dist_bar(post, plot)

                # save plot to html file
                pt = urlable('X'.join([p.name for p in plot]) if isinstance(plot, list) else plot.name)
                fname_gt = os.path.join(self.uploaddir, f"gt-{pt}.html")
                fname_dist = os.path.join(self.uploaddir, f"dist-{pt}.html")

                fig_to_file(gt, fname_gt, ftypes=['.svg', '.html'])
                fig_to_file(dist, fname_dist, ftypes=['.svg', '.html'])

                # register file to make it available as resource
                urls = []
                for fn in [fname_gt, fname_dist]:
                    resname = f'resource/static/image/{Path(fn).stem}.html'
                    with open(fn, 'rb') as f:
                        res = session.runtime.mngr.resources.registerf(resname, 'text/html', f, force=True)
                        u_ = f'http://{session.host}{session.location}{res.location}'
                        urls.append(u_)

                # display plot in separate windows
                open_plot_window_double(urls, pt)

            self.bayrob.result.clear()
            self.lbl_status.text = "OK"
            self._shell.dolayout()

        def open_plot_window_double(
                urls,
                pvars
        ):
            # display ground truth/distribution plot pair in separate window (plotly html in Browser widget)
            wnd_plot = Shell(parent=self._shell, title=pvars,
                             border=True, btnclose=True, btnmin=True,
                             resize=True, modal=False, titlebar=True)
            wnd_plot.on_resize += wnd_plot.dolayout

            w = min(2100., 0.8 * session.runtime.display.width.value)
            h = min(1100., 0.8 * session.runtime.display.height.value)
            wnd_plot.bounds = self._shell.width.value / 2 - w / 2, self._shell.height.value / 2 - h / 2, w, h

            comp_main = Composite(wnd_plot.content, hscroll=True, vscroll=True)
            comp_main.layout = RowLayout(halign='fill', valign='fill', flexrows=1)

            comp_header = Composite(comp_main, hscroll=True, vscroll=True)
            comp_header.layout = ColumnLayout(halign='fill', valign='fill', equalwidths=True)

            Label(comp_header, text='<b>Ground Truth</b>', markup=True, halign='center', valign='center')
            Label(comp_header, text='<b>Distribution</b>', markup=True, halign='center', valign='center')

            comp = Composite(comp_main, hscroll=True, vscroll=True)
            comp.layout = ColumnLayout(halign='fill', valign='fill', flexcols={0: 1, 2: 1})

            Browser(
                comp,
                url=urls[0],
                halign='fill',
                valign='fill'
            )

            Separator(comp, vertical=True, valign='fill')

            Browser(
                comp,
                url=urls[1],
                halign='fill',
                valign='fill'
            )

            wnd_plot.show()

            self.lbl_status.text = "Success!" if self.bayrob.result.success else "Failed!"
            lbl_textresults.text = str(self.bayrob.result)

            self._shell.dolayout()

        def open_plot_window_single(
            url,
            title
        ):
            # display the animated position/direction plot in separate window (plotly html in Browser widget)
            wnd_plot = Shell(parent=self._shell, title=title,
                             border=True, btnclose=True, btnmin=True,
                             resize=True, modal=False, titlebar=True)
            wnd_plot.on_resize += wnd_plot.dolayout

            w = min(1100., 0.8 * session.runtime.display.width.value)
            h = min(1200., 0.8 * session.runtime.display.height.value)
            wnd_plot.bounds = self._shell.width.value / 2 - w / 2, self._shell.height.value / 2 - h / 2, w, h

            comp_main = Composite(wnd_plot.content, hscroll=True, vscroll=True)
            comp_main.layout = RowLayout(halign='fill', valign='fill', flexrows=0)

            comp = Composite(comp_main, hscroll=True, vscroll=True)
            comp.layout = ColumnLayout(halign='fill', valign='fill', flexcols=0)

            Browser(
                comp,
                url=url,
                halign='fill',
                valign='fill'
            )

            wnd_plot.show()

            self.lbl_status.text = "Success!" if self.bayrob.result.success else "Failed!"
            lbl_textresults.text = str(self.bayrob.result)

            self._shell.dolayout()

        @self.checkthread
        def search(*_) -> None:
            # trigger BayRoB search/plan refinement

            # clear previous visualizations and messages and disable controls to prevent interferences, move menu
            # out of view
            clear()
            self.wnd_search.close()
            btn_search.enabled = False
            btn_query_model.enabled = False
            if da_sash_menu.visible:
                da_sash_menu.togglemenu()

            self.lbl_status.text = f'Searching...'
            lbl_textresults.text = f"Searching path: {str(self.asr)}"
            logger.info(f'Searching path: {str(self.asr)}')

            self.run_bayrob(query=self.asr, callback=plot_search_results, runf='astar')

            self._shell.dolayout()

        @self.checkthread
        def query_jpt(*_) -> None:
            # trigger BayRoB query for single model

            # clear previous visualizations and messages and disable controls to prevent interferences, move menu
            # out of view
            clear()
            self.wnd_query_model.close()
            btn_search.enabled = False
            btn_query_model.enabled = False
            if da_sash_menu.visible:
                da_sash_menu.togglemenu()

            self.lbl_status.text = f'Querying...'
            lbl_textresults.text = f"Querying: {str(self.qo)}"
            logger.info(f'Querying: {str(self.qo)}')

            self.run_bayrob(query=self.qo, callback=plot_query_results, runf='queryjpt')

            self._shell.dolayout()

        def search_dialog(*_) -> None:
            # open search window which allows to define init and goal state (or load presets) and trigger
            # search/plan refinement
            if self.wnd_search is not None and not self.wnd_search.disposed:
                # make window visible again and put focus on it
                self.wnd_search.visible = True
                self.wnd_search.focus()
            else:
                self.wnd_search = Shell(parent=self._shell, title='BayRoB Search',
                                             border=True, btnclose=True, btnmin=True,
                                             resize=True, modal=False, titlebar=True)
                # self.wnd_search.on_resize += self.wnd_search.dolayout

                w = 700  # min(700., 0.8 * session.runtime.display.width.value)
                h = 950  # min(800., 0.7 * session.runtime.display.height.value)
                self.wnd_search.bounds = self._shell.width.value/2 - w/2, self._shell.height.value/2 - h/2, w, h
                # scrolled = ScrolledComposite(self.wnd_search.content, valign='fill', halign='fill', vscroll=True, hscroll=True, minwidth=px(w), minheight=px(400))
                comp = Composite(self.wnd_search.content)
                comp.layout = RowLayout(halign='fill', valign='fill', flexrows={2: 1, 7: 1})

                # ==================================================================

                Label(comp, text='Specify goal', valign='center', halign='fill')  # 0
                # multiple combos to select variables from tree
                # contains rows of triples (-, combovariable, text value)
                scrolled_goal = ScrolledComposite(comp,
                                                  valign='fill',
                                                  halign='fill',
                                                  vscroll=True,
                                                  hscroll=True,
                                                  minwidth=px(w-10),
                                                  minheight=px(h/4)
                                                  )  # 1
                comp_goalsettings = Composite(scrolled_goal.content)
                comp_goalsettings.layout = RowLayout(halign='fill', valign='fill', equalheights=True)

                # buttons to add new queryrow and remove entire query block
                Label(comp, text='', valign='fill', halign='fill')  # 2
                comp2 = Composite(comp)  # 3
                comp2.layout = ColumnLayout(halign='left', valign='fill')
                btn_add_queryvar = Button(comp2, '+')
                btn_clear_vars = Button(comp2, 'clear query')
                Separator(comp, horizontal=True, halign='fill')  # 4

                # ==================================================================

                Label(comp, text='Specify init state', valign='center', halign='fill')  # 5
                scrolled_init = ScrolledComposite(comp,
                                                  valign='fill',
                                                  halign='fill',
                                                  vscroll=True,
                                                  hscroll=True,
                                                  minwidth=px(w-10),
                                                  minheight=px(h/4)
                                                  )  # 6

                comp_initsettings = Composite(scrolled_init.content)
                comp_initsettings.layout = RowLayout(halign='fill', valign='fill', equalheights=True)

                # buttons to add new queryrow and remove entire query block
                Label(comp, text='', valign='fill', halign='fill')  # 7
                comp3 = Composite(comp)  # 8
                comp3.layout = ColumnLayout(halign='left', valign='fill')
                btn_add_initvar = Button(comp3, '+')
                btn_clear_initvars = Button(comp3, 'clear init vars')

                # ==================================================================

                grp_strategy = Group(comp, text='Specify search direction')  # 9
                grp_strategy.layout = ColumnLayout(halign='fill', valign='fill', equalwidths=True)

                opt_fwd = Option(grp_strategy, text='forward')
                opt_bwd = Option(grp_strategy, text='backward')

                # ==================================================================

                comp_preset = Composite(comp)  # 10
                comp_preset.layout = ColumnLayout(valign='fill', halign='fill', flexcols=1)
                Label(comp_preset, text='Load preset', valign='center', halign='fill')
                combo_presets = Combo(comp_preset, editable=False, items=self.presets(qtype='search'), minwidth=px(200), halign='fill', valign='fill')

                # ==================================================================

                btn_execute_query = Button(comp, 'Search', valign='fill', halign='fill')  # 11

                # ==================================================================

                self.asr = Search()

                allvars = self.bayrob.models['move'].variables + self.bayrob.models['turn'].variables + \
                          self.bayrob.models['perception'].variables
                allvars_ = {v.name: v for v in allvars}

                def resize_scrolled(*_):
                    _, _, w, h = self.wnd_search.bounds
                    w = min(700., w)
                    h = min(950., h)
                    # scrolled.layout.minwidth = px(w)
                    # scrolled.layout.minheight = px(min(400, h))
                    scrolled_goal.layout.minwidth = px(w-10)
                    scrolled_goal.layout.minheight = px(h/4)
                    scrolled_init.layout.minwidth = px(w-10)
                    scrolled_init.layout.minheight = px(h/4)
                    self.wnd_search.dolayout()

                def updatesearchdir(*_):
                    self.asr.bwd = opt_bwd.checked

                def add_goalvar_row(*_):
                    # goal state specification:
                    # add row containing dropdown box for variable selection (all variables from all models), value
                    # specification, (tolerance specification for Numeric variables) and button to remove entire row

                    comp_tmp = Composite(comp_goalsettings)
                    comp_tmp.layout = ColumnLayout(halign='fill', valign='fill', flexcols=[0, 1])
                    combo_vars = Combo(comp_tmp, editable=False, items=allvars, minwidth=px(200), halign='fill', valign='fill')
                    lbl_vals = Edit(comp_tmp, message="value", editable=True, minwidth=px(200), valign='fill', halign='fill')
                    lbl_tol = Edit(comp_tmp, message="tolerance", editable=True, minwidth=px(200), valign='fill', halign='fill')
                    lbl_tol.enabled = False
                    btn_rem_queryvar = Button(comp_tmp, '-', valign='fill', halign='fill')

                    def add_goalvar(*_) -> None:
                        # add variable represented by row to goal state specification

                        self.asr.goal[combo_vars.selection] = self.parseval(
                            lbl_vals.text,
                            var=combo_vars.selection,
                            onlysets=True
                        )

                    def add_tolerance(*_) -> None:
                        self.asr.goal_tolerances[combo_vars.selection] = self.parseval(
                            lbl_tol.text,
                            var=combo_vars.selection,
                            onlysets=True
                        )

                    def rem_goalvar(*_) -> None:
                        # remove variable represented by row from goal state specification

                        if combo_vars.selection in self.asr.goal and self.asr.goal[combo_vars.selection] == lbl_vals.text:
                            del self.asr.goal[combo_vars.selection]
                        if combo_vars.selection in self.asr.goal_tolerances and self.asr.goal_tolerances[combo_vars.selection] == lbl_tol.text:
                            del self.asr.goal_tolerances[combo_vars.selection]
                        comp_tmp.dispose()

                    def update_suggestions(*_) -> None:
                        # add message with suggestions for possible values depending on selected variable

                        lbl_vals.message = self.suggestions(combo_vars.selection)
                        lbl_tol.enabled = combo_vars.selection.domain is Numeric
                        self.wnd_search.dolayout()

                    btn_rem_queryvar.on_select += rem_goalvar
                    combo_vars.on_select += update_suggestions
                    lbl_vals.on_modify += add_goalvar
                    lbl_tol.on_modify += add_tolerance
                    self.wnd_search.dolayout()

                def add_initvar_row(*_):
                    # init state specification:
                    # add row containing dropdown box for variable selection (all variables from all models), value
                    # specification, (tolerance specification for Numeric variables) and button to remove entire row

                    comp_tmp = Composite(comp_initsettings)
                    comp_tmp.layout = ColumnLayout(halign='fill', valign='fill', flexcols=[0, 1])
                    combo_vars = Combo(comp_tmp, editable=False, items=allvars, minwidth=px(200), halign='fill', valign='fill')
                    lbl_vals = Edit(comp_tmp, message="value", editable=True, minwidth=px(200), valign='fill', halign='fill')
                    lbl_tol = Edit(comp_tmp, message="tolerance", editable=True, minwidth=px(200), valign='fill', halign='fill')
                    lbl_tol.enabled = False
                    btn_rem_queryvar = Button(comp_tmp, '-', valign='fill', halign='fill')

                    def add_initvar(*_) -> None:
                        # add variable represented by row to init state specification

                        self.asr.init[combo_vars.selection] = self.parseval(
                            lbl_vals.text,
                            var=combo_vars.selection,
                            onlysets=True
                        )

                    def add_tolerance(*_) -> None:
                        self.asr.init_tolerances[combo_vars.selection] = self.parseval(
                            lbl_tol.text,
                            var=combo_vars.selection,
                            onlysets=True
                        )

                    def rem_initvar(*_) -> None:
                        # remove variable represented by row from init state specification

                        if combo_vars.selection in self.asr.init and self.asr.init[combo_vars.selection] == lbl_vals.text:
                            del self.asr.init[combo_vars.selection]
                        if combo_vars.selection in self.asr.init_tolerances and self.asr.init_tolerances[combo_vars.selection] == lbl_tol.text:
                            del self.asr.init[combo_vars.selection]
                        comp_tmp.dispose()

                    def update_suggestions(*_) -> None:
                        # add message with suggestions for possible values depending on selected variable

                        lbl_vals.message = self.suggestions(combo_vars.selection)
                        lbl_tol.enabled = combo_vars.selection.domain is Numeric
                        self.wnd_search.dolayout()

                    btn_rem_queryvar.on_select += rem_initvar
                    combo_vars.on_select += update_suggestions
                    lbl_vals.on_modify += add_initvar
                    lbl_tol.on_modify += add_tolerance
                    self.wnd_search.dolayout()

                def loadpreset(*_):
                    # update init and goal state according to predefined settings, update summary texts

                    preset = combo_presets.selection
                    clear_goal()
                    clear_init()

                    for k, v in preset['init'].items():
                        add_initvar_row()
                        c = comp_initsettings.children[-1]
                        c.children[0].selidx = [var.name for var in c.children[0].items.values()].index(k)
                        c.children[1].text = str(v)

                    for k, v in preset['goal'].items():
                        add_goalvar_row()
                        c = comp_goalsettings.children[-1]
                        c.children[0].selidx = [var.name for var in c.children[0].items.values()].index(k)
                        c.children[1].text = str(v)

                    if preset['bwd']:
                        opt_bwd.checked = True
                        opt_fwd.checked = False
                    else:
                        opt_bwd.checked = False
                        opt_fwd.checked = True

                    self.asr.init = {allvars_[k]: v for k, v in preset['init'].items()}
                    self.asr.init_tolerances = {allvars_[k]: v for k, v in preset['init_tolerances'].items()}
                    self.asr.goal = {allvars_[k]: v for k, v in preset['goal'].items()}
                    self.asr.goal_tolerances = {allvars_[k]: v for k, v in preset['goal_tolerances'].items()}
                    self.asr.bwd = preset['bwd']

                    self.wnd_search.dolayout()

                def clear_goal(*_):
                    # remove all goal state specifications

                    children = [c for c in comp_goalsettings.children]
                    for c in children:
                        c.dispose()
                    btn_add_queryvar.enabled = True
                    btn_add_initvar.enabled = True
                    self.wnd_search.dolayout()

                def clear_init(*_):
                    # remove all init state specifications

                    children = [c for c in comp_initsettings.children]
                    for c in children:
                        c.dispose()
                    btn_add_queryvar.enabled = True
                    btn_add_initvar.enabled = True
                    self.wnd_search.dolayout()

                # ==================================================================

                self.wnd_search.on_resize += resize_scrolled
                btn_add_queryvar.on_select += add_goalvar_row
                btn_add_initvar.on_select += add_initvar_row
                btn_clear_vars.on_select += clear_goal
                btn_clear_initvars.on_select += clear_init
                combo_presets.on_select += loadpreset
                btn_execute_query.on_select += search
                opt_bwd.on_checked += updatesearchdir
                opt_fwd.on_checked += updatesearchdir
                opt_bwd.checked = True

            self.wnd_search.show()

        def query_model_dialog(*_) -> None:

            # open query window which allows to select model to query, specify query variables and select variables
            # to be plotted
            if self.wnd_query_model is not None and not self.wnd_query_model.disposed:
                # make window visible again and put focus on it
                self.wnd_query_model.visible = True
                self.wnd_query_model.focus()
            else:
                self.wnd_query_model = Shell(parent=self._shell, title='BayRoB Query',
                                             border=True, btnclose=True, btnmin=True,
                                             resize=True, modal=False, titlebar=True)
                # self.wnd_query_model.on_resize += self.wnd_query_model.dolayout

                w = 500  # min(700., 0.8 * session.runtime.display.width.value)
                h = 1000  # min(900., 0.9 * session.runtime.display.height.value)
                self.wnd_query_model.bounds = self._shell.width.value/2 - w/2, self._shell.height.value/2 - h/2, w, h
                # scrolled = ScrolledComposite(self.wnd_query_model.content,
                #                              valign='fill',
                #                              halign='fill',
                #                              vscroll=True,
                #                              hscroll=True,
                #                              minwidth=px(w),
                #                              minheight=px(400)
                #                              )
                comp = Composite(self.wnd_query_model.content)
                comp.layout = RowLayout(halign='fill', valign='fill', flexrows={5: 1, 10: 1})

                # ==================================================================

                # combo to select tree model
                Label(comp, text='Select model', valign='fill', halign='fill')  # 0
                combo_models = Combo(comp, editable=False, items=[], halign='fill')  # 1
                Separator(comp, horizontal=True, halign='fill')  # 2

                # ==================================================================

                # multiple combos to select variables from trees
                # contains rows of triples (-, combovariable, text value)
                Label(comp, text='Specify observation(s)', valign='fill', halign='fill')  # 3
                scrolled_var = ScrolledComposite(comp,
                                                  valign='fill',
                                                  halign='fill',
                                                  vscroll=True,
                                                  hscroll=True,
                                                  minwidth=px(w-10),
                                                  minheight=px(.25*h)
                                                  )  # 4
                comp_varsettings = Composite(scrolled_var.content)
                comp_varsettings.layout = RowLayout(halign='fill', valign='fill', equalheights=True)

                # buttons to add new queryrow and remove entire query block
                Label(comp, text='', valign='fill', halign='fill')  # 5
                comp2 = Composite(comp)  # 6
                comp2.layout = ColumnLayout(halign='left', valign='fill')
                btn_add_queryvar = Button(comp2, '+')
                btn_clear_vars = Button(comp2, 'clear evidence')
                btn_add_queryvar.enabled = False
                Separator(comp, horizontal=True, halign='fill')  # 7

                # ==================================================================

                Label(comp, text='Select query variables', valign='fill', halign='fill')  # 8
                scrolled_plot = ScrolledComposite(comp,
                                                  valign='fill',
                                                  halign='fill',
                                                  vscroll=True,
                                                  hscroll=True,
                                                  minwidth=px(w - 10),
                                                  minheight=px(.25*h)
                                                  )  # 9
                comp_varplot = Composite(scrolled_plot.content)  # 9
                comp_varplot.layout = RowLayout(halign='fill', valign='fill', equalheights=True)

                # buttons to add new queryrow and remove entire query block
                Label(comp, text='', valign='fill', halign='fill')  # 10
                comp3 = Composite(comp)
                comp3.layout = ColumnLayout(halign='left', valign='fill')
                btn_add_plotvar = Button(comp3, '+')
                btn_add_plotvar.enabled = False
                btn_clear_plotvars = Button(comp3, 'clear query variables')

                # ==================================================================

                comp_preset = Composite(comp)  # 11
                comp_preset.layout = ColumnLayout(valign='fill', halign='fill', flexcols=1)
                Label(comp_preset, text='Load preset', valign='center', halign='fill')
                combo_presets = Combo(comp_preset, editable=False, items={}, minwidth=px(200), halign='fill',valign='fill')
                combo_presets.enabled = False

                # ==================================================================

                btn_execute_query = Button(comp, 'Query', valign='fill', halign='fill')  # 13

                # ==================================================================

                self.qo = Query()

                def resize_scrolled(*_):
                    _, _, w, h = self.wnd_query_model.bounds
                    w = min(500., w)
                    h = min(1000., h)
                    # scrolled.layout.minwidth = px(w)
                    # scrolled.layout.minheight = px(min(400, h))
                    scrolled_var.layout.minwidth = px(w-10)
                    scrolled_var.layout.minheight = px(.25*h)
                    scrolled_plot.layout.minwidth = px(w-10)
                    scrolled_plot.layout.minheight = px(.25*h)
                    self.wnd_query_model.dolayout()

                def add_queryvar_row(*_):
                    # query specification:
                    # add row containing dropdown box for variable selection (variables from selected model), value
                    # specification and button to remove entire row

                    btn_add_queryvar.enabled = True

                    comp_tmp = Composite(comp_varsettings)
                    comp_tmp.layout = ColumnLayout(halign='fill', valign='fill', flexcols=[0, 1])
                    combo_vars = Combo(comp_tmp, editable=False, items=self.qo.model.variables, minwidth=px(200), halign='fill', valign='fill')
                    lbl_vals = Edit(comp_tmp, message="value", editable=True, minwidth=px(200), valign='fill', halign='fill')
                    btn_rem_queryvar = Button(comp_tmp, '-', valign='fill', halign='fill')

                    def add_queryvar(*_) -> None:
                        # add variable represented by row to query specification

                        self.qo.evidence[combo_vars.selection] = self.parseval(
                            lbl_vals.text,
                            var=combo_vars.selection
                        )
                        updatequery()

                    def rem_queryvar(*_) -> None:
                        # remove variable represented by row from query specification

                        if combo_vars.selection in self.qo.evidence and self.qo.evidence[combo_vars.selection] == lbl_vals.text:
                            del self.qo.evidence[combo_vars.selection]
                        comp_tmp.dispose()
                        updatequery()

                    def update_suggestions(*_) -> None:
                        # add message with suggestions for possible values depending on selected variable

                        lbl_vals.message = self.suggestions(combo_vars.selection)
                        self.wnd_query_model.dolayout()

                    btn_rem_queryvar.on_select += rem_queryvar
                    combo_vars.on_select += update_suggestions
                    lbl_vals.on_modify += add_queryvar
                    self.wnd_query_model.dolayout()

                def add_plotvar_row(*_) -> None:
                    # plot specification:
                    # add row containing dropdown box for variable selection (variables from selected model) and
                    # button to remove row

                    btn_add_plotvar.enabled = True

                    comp_tmp = Composite(comp_varplot)
                    comp_tmp.layout = ColumnLayout(halign='fill', valign='fill', flexcols=[0])
                    combo_vars = Combo(comp_tmp, editable=False, items=self.presets('queryvars').get(self.qo.modelname, {}), minwidth=px(200), halign='fill', valign='fill')
                    btn_rem_var = Button(comp_tmp, '-', valign='fill', halign='fill')

                    def add_plotvar(*_) -> None:
                        # add variable represented by row to list of plots

                        self.qo.queryvars.append(combo_vars.selection)
                        updateplot()

                    def rem_plotvar(*_) -> None:
                        # remove variable represented by row from list of plots

                        if combo_vars.selection in self.qo.queryvars:
                            self.qo.queryvars.remove(combo_vars.selection)
                        comp_tmp.dispose()
                        updateplot()
                        self.wnd_query_model.dolayout()

                    btn_rem_var.on_select += rem_plotvar
                    combo_vars.on_select += add_plotvar
                    self.wnd_query_model.dolayout()

                def updatequery(*_):
                    # update the text summary of query so far

                    self.qo.querystr = build_constraints({k.name: v for k,v in self.qo.evidence.items()})
                    # edit_querypreview.text = f"Evidence: {self.qo.querystr} \nQuery variables: {', '.join([str(x) for x in self.qo.queryvars])}"
                    self.wnd_query_model.dolayout()

                def updateplot(*_) -> None:
                    # update the text summary variables to plot

                    # edit_querypreview.text = f"Evidence: {self.qo.querystr} \nQuery variables: {', '.join([str(x) for x in self.qo.queryvars])}"
                    self.wnd_query_model.dolayout()

                def loadpreset(*_):
                    # update init and goal state according to predefined settings, update summary texts

                    preset = combo_presets.selection
                    clear_query()
                    clear_plot()

                    logger.error(f"Loading query preset for model {self.qo.modelname}:", preset)
                    for k, v in preset['evidence'].items():
                        add_queryvar_row()
                        c = comp_varsettings.children[-1]
                        c.children[0].selidx = [var.name for var in c.children[0].items.values()].index(k)
                        c.children[1].text = str(v)

                    logger.error({self.qo.model.varnames[k]: self.parseval(
                            v,
                            var=self.qo.model.varnames[k]
                        ) for k, v in preset['evidence'].items()})

                    self.qo.evidence = {self.qo.model.varnames[k]: self.parseval(
                            v,
                            var=self.qo.model.varnames[k]
                        ) for k, v in preset['evidence'].items()}
                    self.qo.queryvars = [self.qo.model.varnames[k] for k in preset['queryvars']]
                    updatequery()
                    updateplot()

                    #
                    # for k, v in preset['init'].items():
                    #     add_initvar_row()
                    #     c = comp_initsettings.children[-1]
                    #     c.children[0].selidx = [var.name for var in c.children[0].items.values()].index(k)
                    #     c.children[1].text = str(v)
                    #
                    # for k, v in preset['goal'].items():
                    #     add_goalvar_row()
                    #     c = comp_goalsettings.children[-1]
                    #     c.children[0].selidx = [var.name for var in c.children[0].items.values()].index(k)
                    #     c.children[1].text = str(v)
                    #
                    # if preset['bwd']:
                    #     opt_bwd.checked = True
                    #     opt_fwd.checked = False
                    # else:
                    #     opt_bwd.checked = False
                    #     opt_fwd.checked = True
                    #
                    # self.asr.init = {allvars_[k]: v for k, v in preset['init'].items()}
                    # self.asr.init_tolerances = {allvars_[k]: v for k, v in preset['init_tolerances'].items()}
                    # self.asr.goal = {allvars_[k]: v for k, v in preset['goal'].items()}
                    # self.asr.goal_tolerances = {allvars_[k]: v for k, v in preset['goal_tolerances'].items()}
                    # self.asr.bwd = preset['bwd']

                def clear_query(*_):
                    # remove all query specifications

                    children = [c for c in comp_varsettings.children]
                    for c in children:
                        if c.children[0].selection in self.qo.evidence:
                            del self.qo.evidence[c.children[0].selection]
                        c.dispose()
                    btn_add_queryvar.enabled = True
                    btn_add_plotvar.enabled = True
                    self.qo.model = combo_models.selection
                    self.qo.modelname = list(combo_models.items.keys())[combo_models.selidx]

                    combo_presets.items = self.presets(qtype='queryjpt').get(self.qo.modelname, {})
                    combo_presets.enabled = True

                    self.wnd_query_model.dolayout()

                def clear_plot(*_):
                    # remove all variables from plot list

                    self.qo.queryvars = []
                    children = [c for c in comp_varplot.children]
                    for c in children:
                        c.dispose()
                    btn_add_queryvar.enabled = True
                    btn_add_plotvar.enabled = True
                    self.qo.model = combo_models.selection
                    self.qo.modelname = list(combo_models.items.keys())[combo_models.selidx]
                    updateplot()
                    self.wnd_query_model.dolayout()

                # ==================================================================

                self.wnd_query_model.on_resize += resize_scrolled
                combo_models.on_select += clear_query
                combo_models.on_select += clear_plot
                combo_models.items = self.bayrob.models
                btn_add_queryvar.on_select += add_queryvar_row
                btn_add_plotvar.on_select += add_plotvar_row
                btn_clear_vars.on_select += clear_query
                btn_clear_vars.on_select += updatequery
                btn_clear_plotvars.on_select += clear_plot
                btn_clear_plotvars.on_select += updatequery
                combo_presets.on_select += loadpreset
                btn_execute_query.on_select += query_jpt

            self.wnd_query_model.show()

        #################
        # SET LISTENERS #
        #################
        btn_query_model.on_select += query_model_dialog
        btn_search.on_select += search_dialog
        tabfldr_body.selected = 0

        self._shell.show()

    # = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
    # MOBILE VERSION
    # = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
    def mobile(self, **kwargs) -> None:
        self._shell = Shell(maximized=True, titlebar=False)
        self._shell.bg = Color('transp')
        self._shell.on_resize += self._shell.dolayout

        comp_mainframe = Composite(self._shell.content)
        comp_mainframe.layout = RowLayout(halign='fill', valign='fill', flexrows={1: 1}, vspace=0)

        # * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        # HEADER
        # * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        comp_header = Composite(comp_mainframe)
        comp_header.layout = ColumnLayout(halign='fill', flexcols={1: 0.2, 4: 0.2}, padding=Pixels(0))
        # comp_header.css = 'navbar'
        comp_header.bgimg = Image(res('static/images/dark-metal-texture_rot.png'))

        # LOGOS #
        h = 35
        _logo = Image(res('static/images/logo.png')).resize(height=px(int(h)))
        h = _logo.height
        logo = Label(comp_header, padding=Pixels(0), img=_logo, valign='top')
        logo.bg = Color('transp')
        Label(comp_header, padding=Pixels(0))
        ailogo = Label(comp_header, img=Image(res('static/images/ai_logo_white.png')).resize(height=Pixels(.9 * h)), valign='center', halign='center')
        ailogo.bg = Color('transp')
        Label(comp_header, padding=Pixels(0))

        # MENU #
        menulabel = Label(comp_header, img=Image(res('static/images/menu.png')).resize(height=Pixels(.9 * h)), valign='center', halign='right', padding=Pixels(5))
        menulabel.layout.minheight = Pixels(.6 * h)
        menulabel.bg = 'transp'

        # * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        # BODY
        # * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        comp_body = Composite(comp_mainframe, border=True)
        comp_body.layout = StackLayout(halign='fill', valign='fill')
        comp_body.bg = Color('white')

        self.lbl_status = Label(comp_mainframe, text='', valign='fill', halign='fill')

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

        # HOME PAGE #
        comp_home = Composite(comp_body)
        comp_home.layout = RowLayout(flexrows=0, halign='fill', valign='fill')
        comp_home.bg = Color('white')
        comp_home.visible = False

        comp = Composite(comp_home, hscroll=True, vscroll=True)
        comp.layout = RowLayout(halign='fill', valign='fill', flexrows=0)

        comp_profile = Composite(comp)
        comp_profile.layout = ColumnLayout(halign='fill', valign='fill', flexcols=0)

        comp_features = Composite(comp_profile)
        comp_features.layout = RowLayout(halign='fill', valign='fill', flexrows=0)

        # TODO temporary preset loading and threshold entering, prettify or remove!
        combo_presets = Label(comp_features, "HI", halign='fill', valign='fill')

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

        # DEFINE REQUIREMENT PROFILE PAGE #
        comp_search = Composite(comp_body)
        comp_search.layout = RowLayout(halign='fill', valign='fill', flexrows=0)
        comp_search.visible = True

        w = session.runtime.display.width.value
        h = session.runtime.display.height.value

        scrolled = ScrolledComposite(comp_search, valign='fill', halign='fill', vscroll=True, hscroll=True, minwidth=px(w), minheight=px(h))
        comp = Composite(scrolled.content)
        comp.layout = RowLayout(halign='fill', valign='fill', flexrows={8: 1})

        # ==================================================================

        Label(comp, text='Specify goal', valign='center', halign='fill')  # 0
        # multiple combos to select variables from tree
        # contains rows of triples (-, combovariable, text value)
        scrolled_goal = ScrolledComposite(comp,
                                          valign='fill',
                                          halign='fill',
                                          vscroll=True,
                                          hscroll=True,
                                          minwidth=px(w),
                                          minheight=px(h / 6)
                                          )  # 1
        comp_goalsettings = Composite(scrolled_goal.content)
        comp_goalsettings.layout = RowLayout(halign='fill', valign='fill', equalheights=True)

        # buttons to add new queryrow and remove entire query block
        comp2 = Composite(comp)  # 2
        comp2.layout = ColumnLayout(halign='left', valign='fill')
        btn_add_queryvar = Button(comp2, '+')
        btn_clear_vars = Button(comp2, 'clear query')
        Separator(comp, horizontal=True, halign='fill')  # 3

        # ==================================================================

        Label(comp, text='Specify init state', valign='center', halign='fill')  # 4
        scrolled_init = ScrolledComposite(comp,
                                          valign='fill',
                                          halign='fill',
                                          vscroll=True,
                                          hscroll=True,
                                          minwidth=px(w - 5),
                                          minheight=px(h / 6)
                                          )  # 5

        comp_initsettings = Composite(scrolled_init.content)
        comp_initsettings.layout = RowLayout(halign='fill', valign='fill', equalheights=True)

        # buttons to add new queryrow and remove entire query block
        comp3 = Composite(comp)  # 6
        comp3.layout = ColumnLayout(halign='left', valign='fill')
        btn_add_initvar = Button(comp3, '+')
        btn_clear_initvars = Button(comp3, 'clear init vars')

        # ==================================================================

        # Label(comp, text='Specify search direction', valign='center', halign='fill')
        grp_strategy = Group(comp, text='Specify search direction')  # 7
        grp_strategy.layout = ColumnLayout(halign='fill', valign='fill', equalwidths=True)

        opt_fwd = Option(grp_strategy, text='forward')
        opt_bwd = Option(grp_strategy, text='backward')

        # ==================================================================

        comp_preset = Composite(comp)  # 8
        comp_preset.layout = ColumnLayout(valign='fill', halign='fill', flexcols=1)
        Label(comp_preset, text='Load preset', valign='center', halign='fill')  # 9
        combo_presets = Combo(comp_preset, editable=False, items=self.presets(qtype='search'), minwidth=px(50),
                              halign='fill', valign='fill')

        # ==================================================================

        btn_search = Button(comp, 'Search', valign='fill', halign='fill')  # 10

        # ==================================================================

        self.asr = Search()

        allvars = self.bayrob.models['move'].variables + self.bayrob.models['turn'].variables + \
                  self.bayrob.models['perception'].variables
        allvars_ = {v.name: v for v in allvars}

        def resize_scrolled(*_):
            _, _, w, h = self._shell.bounds
            scrolled.layout.minwidth = px(w)
            scrolled.layout.minheight = px(h)
            scrolled_goal.layout.minwidth = px(w - 5)
            scrolled_goal.layout.minheight = px(h / 6)
            scrolled_init.layout.minwidth = px(w - 5)
            scrolled_init.layout.minheight = px(h / 6)
            self._shell.dolayout()

        def updatesearchdir(*_):
            self.asr.bwd = opt_bwd.checked

        def add_goalvar_row(*_):
            # goal state specification:
            # add row containing dropdown box for variable selection (all variables from all models), value
            # specification, (tolerance specification for Numeric variables) and button to remove entire row

            comp_tmp = Composite(comp_goalsettings)
            comp_tmp.layout = ColumnLayout(halign='fill', valign='fill', flexcols={0: 1})
            combo_vars = Combo(comp_tmp, editable=False, items=allvars, halign='fill', valign='fill', minwidth=px(200))
            lbl_vals = Edit(comp_tmp, message="value", editable=True, valign='fill', halign='fill', minwidth=px(50))
            lbl_tol = Edit(comp_tmp, message="tolerance", editable=True, valign='fill', halign='fill', minwidth=px(50))
            lbl_tol.enabled = False
            btn_rem_queryvar = Button(comp_tmp, '-', valign='fill', halign='fill')

            def add_goalvar(*_) -> None:
                # add variable represented by row to goal state specification

                self.asr.goal[combo_vars.selection] = self.parseval(
                    lbl_vals.text,
                    var=combo_vars.selection,
                    onlysets=True
                )
                self.asr.goal_tolerances[combo_vars.selection] = lbl_tol.text

            def rem_goalvar(*_) -> None:
                # remove variable represented by row from goal state specification

                if combo_vars.selection in self.asr.goal and self.asr.goal[combo_vars.selection] == lbl_vals.text:
                    del self.asr.goal[combo_vars.selection]
                if combo_vars.selection in self.asr.goal_tolerances and self.asr.goal_tolerances[
                    combo_vars.selection] == lbl_tol.text:
                    del self.asr.goal_tolerances[combo_vars.selection]
                comp_tmp.dispose()

            def update_suggestions(*_) -> None:
                # add message with suggestions for possible values depending on selected variable

                lbl_vals.message = self.suggestions(combo_vars.selection)
                lbl_tol.enabled = combo_vars.selection.domain is Numeric
                self._shell.dolayout()

            btn_rem_queryvar.on_select += rem_goalvar
            combo_vars.on_select += update_suggestions
            lbl_vals.on_modify += add_goalvar
            self._shell.dolayout()

        def add_initvar_row(*_):
            # init state specification:
            # add row containing dropdown box for variable selection (all variables from all models), value
            # specification, (tolerance specification for Numeric variables) and button to remove entire row

            comp_tmp = Composite(comp_initsettings)
            comp_tmp.layout = ColumnLayout(halign='fill', valign='fill', flexcols={0: 1})
            combo_vars = Combo(comp_tmp, editable=False, items=allvars, minwidth=px(200), halign='fill', valign='fill')
            lbl_vals = Edit(comp_tmp, message="value", editable=True, minwidth=px(50), valign='fill', halign='fill')
            lbl_tol = Edit(comp_tmp, message="tolerance", editable=True, minwidth=px(50), valign='fill', halign='fill')
            lbl_tol.enabled = False
            btn_rem_queryvar = Button(comp_tmp, '-', valign='fill', halign='fill')

            def add_initvar(*_) -> None:
                # add variable represented by row to init state specification

                self.asr.init[combo_vars.selection] = self.parseval(
                    lbl_vals.text,
                    var=combo_vars.selection,
                    onlysets=True
                )
                self.asr.init_tolerances[combo_vars.selection] = lbl_tol.text

            def rem_initvar(*_) -> None:
                # remove variable represented by row from init state specification

                if combo_vars.selection in self.asr.init and self.asr.init[combo_vars.selection] == lbl_vals.text:
                    del self.asr.init[combo_vars.selection]
                if combo_vars.selection in self.asr.init_tolerances and self.asr.init_tolerances[
                    combo_vars.selection] == lbl_tol.text:
                    del self.asr.init[combo_vars.selection]
                comp_tmp.dispose()

            def update_suggestions(*_) -> None:
                # add message with suggestions for possible values depending on selected variable

                lbl_vals.message = self.suggestions(combo_vars.selection)
                lbl_tol.enabled = combo_vars.selection.domain is Numeric
                self.wnd_search.dolayout()

            btn_rem_queryvar.on_select += rem_initvar
            combo_vars.on_select += update_suggestions
            lbl_vals.on_modify += add_initvar
            self._shell.dolayout()

        def loadpreset(*_):
            # update init and goal state according to predefined settings, update summary texts

            preset = combo_presets.selection
            clear_goal()
            clear_init()

            logger.error(f"Loading search preset:", preset)
            for k, v in preset['init'].items():
                add_initvar_row()
                c = comp_initsettings.children[-1]
                c.children[0].selidx = [var.name for var in c.children[0].items.values()].index(k)
                c.children[1].text = str(v)

            for k, v in preset['goal'].items():
                add_goalvar_row()
                c = comp_goalsettings.children[-1]
                c.children[0].selidx = [var.name for var in c.children[0].items.values()].index(k)
                c.children[1].text = str(v)

            if preset['bwd']:
                opt_bwd.checked = True
                opt_fwd.checked = False
            else:
                opt_bwd.checked = False
                opt_fwd.checked = True

            self.asr.init = {allvars_[k]: v for k, v in preset['init'].items()}
            self.asr.init_tolerances = {allvars_[k]: v for k, v in preset['init_tolerances'].items()}
            self.asr.goal = {allvars_[k]: v for k, v in preset['goal'].items()}
            self.asr.goal_tolerances = {allvars_[k]: v for k, v in preset['goal_tolerances'].items()}
            self.asr.bwd = preset['bwd']

            self._shell.dolayout()

        def clear_goal(*_):
            # remove all goal state specifications

            children = [c for c in comp_goalsettings.children]
            for c in children:
                c.dispose()
            btn_add_queryvar.enabled = True
            btn_add_initvar.enabled = True
            self._shell.dolayout()

        def clear_init(*_):
            # remove all init state specifications

            children = [c for c in comp_initsettings.children]
            for c in children:
                c.dispose()
            btn_add_queryvar.enabled = True
            btn_add_initvar.enabled = True
            self._shell.dolayout()

        # ==================================================================

        self._shell.on_resize += resize_scrolled
        btn_add_queryvar.on_select += add_goalvar_row
        btn_add_initvar.on_select += add_initvar_row
        btn_clear_vars.on_select += clear_goal
        btn_clear_initvars.on_select += clear_init
        combo_presets.on_select += loadpreset
        # btn_execute_query.on_select += search
        opt_bwd.on_checked += updatesearchdir
        opt_fwd.on_checked += updatesearchdir
        opt_bwd.checked = True

        # comp_radar = ScrolledComposite(comp_search, valign='fill', halign='fill', vscroll=True, hscroll=True)

        # radar_req = Radar(comp_radar.content, legendtext='', halign='fill', valign='fill', minwidth=self._shell.bounds[2], minheight=self._shell.bounds[3]*0.7)

        # LISTENER FUNCTIONS
        # def setinterval(axis) -> None:
        #     answer = ask_input(self._shell, 'Enter Interval for axis "{}"'.format(axis), message='[-2,3]')
        #     if answer is not None:
        #         try:
        #             interval = ContinuousSet.fromstring(answer)
        #             radar_req.interval(axis, minval=interval.lower, maxval=interval.upper)
        #         except:
        #             msg_err(self._shell, 'Error', 'Unable to set Interval {}. Please use a valid notation (e.g. [-2,3])'.format(answer))
        #
        # def remaxis(axis) -> None:
        #     radar_req.remaxisbyname(axis)
        #     lbl_status.text = 'Axis "{0}" was removed and will hence be ignored.'.format(axis)

        # def open_menu(axis):
        #     # show menu for right click on axis in requirement profile radar
        #
        #     # AXIS MENU #
        #     menuentries = OrderedDict([
        #         ('Set interval', setinterval),
        #         ('Remove axis "{}"'.format(axis), remaxis)
        #     ])
        #
        #     answer, callback = options_list(self._shell, menuentries)
        #     callback(axis)
        #
        # lbl_req_changes = Label(comp_search, text='<b>Requirement changes:</b>', markup=True, halign='fill', valign='fill')
        # lbl_req_changes.visible = False
        # btn_query = Button(comp_search, 'Query')

        # def sel(*kwargs) -> None:
        #     # listener function for interaction with requirement profile radar chart.
        #     # Handles feedback for user
        #     d = kwargs[0].args[0]
        #     stat = ''
        #     if d.get('type') == 'circle':
        #         stat = 'The {1[name]} value for the alloy {0} has been changed to {1[value]}!'.format(d['dataset'], d['data'])
        #     elif d.get('type') in ['mininterval', 'rs_miniv']:
        #         stat = 'The lower bound for the property "{0[name]}" was set to {1}!'.format(d['dataset'], d['data'])
        #     elif d.get('type') in ['maxinterval', 'rs_maxiv']:
        #         stat = 'The upper bound for the property "{0[name]}" was set to {1}!'.format(d['dataset'], d['data'])
        #     elif d.get('type') == 'axis':
        #         if kwargs[0].button == 'right':
        #             switchpage(d['axis'])
        #             return
        #     else:
        #         stat = 'invalid datatype {}'.format(d.get('type'))
        #     lbl_status.text = stat

        # def update(self) -> None:
        #     # initialize radar chart containing candidate datasets
        #     self.candidates = self.bayrob.hypotheses
        #     radar_candidates = Radar(comp_res.content, legendtext='Hypotheses', halign='fill', valign='fill', minwidth=self._shell.bounds[2], minheight=self._shell.bounds[3]*0.7)
        #
        #     # create empty radar chart from requirement profile
        #     for axis in radar_req.axes:
        #         radar_candidates.addaxis(axis.name,
        #                                  minval=axis.minval,
        #                                  maxval=axis.maxval,
        #                                  unit=axis.unit,
        #                                  intervalmin=axis.intervalmin,
        #                                  intervalmax=axis.intervalmax)
        #
        #     data = {}
        #     for i, hyp in enumerate(self.candidates):
        #         pathvals = hyp.result
        #         values = [pathvals.get(a.name, 0) for a in radar_candidates.axes]
        #         data.update({hyp.id: values})
        #         table_candidates.additem([hyp.id, str(hyp.performance)])
        #
        #     # sort results in table descending by probability
        #     sort_by_sim(down=True)
        #
        #     # data maps example name (=material) to (sorted) list of values for the radar chart axes
        #     radar_candidates.setdata(data)
        #     lbl_status.text = '...done! Found {} candidates.'.format(len(self.candidates))
        #
        #     switchpage(None, comp_candidates)
        #
        #     self._shell.dolayout()
        #
        # def showproc(*_) -> None:
        #     if self.bayrob.resulttree:
        #         cnamefull = table_candidates.selection.texts[0]
        #
        #         # self.candidates is a list of [confs, RegressionTree nodes (path from leaf to src)]
        #         # construct data for tree
        #         generate_nodes()
        #         data = nodedict(self.bayrob.resulttree.src, cnamefull)
        #
        #         tree.setdata(data)
        #
        #         switchpage(None, comp_tree)
        #
        # def generate_nodes() -> None:
        #     parentnode = ResTree.Node(None, nodetext='Start', printnode=False)
        #     parentnode.isroot = True
        #     parentnode.parameters = self.bayrob.query
        #     self.bayrob.resulttree.src = parentnode
        #
        #     hyps = self.bayrob.hypotheses.copy()
        #     generate_nodes_rec(self.bayrob.resulttree.src, hyps, 0)
        #
        # def generate_nodes_rec(parent, hypotheses, d) -> None:
        #     for h in hypotheses:
        #         if d < len(h.steps):
        #             step = h.steps[d]
        #
        #             # create node if not exists yet
        #             n_ = ResTree.Node(parent, printnode=False)
        #             n_.nodetext = 'H_' + '.'.join([str(el) for el in h.identifiers[:d+1]])
        #             n_.edgetext = step.name
        #             n_.result = step.value.copy()
        #             n_.parameters = step.path.copy()
        #             n_.confs = h.performance
        #
        #             # leaf nodes show confs and overall result instead of step result
        #             if d == len(h.steps)-1:
        #                 n_.nodetext = h.id
        #                 n_.result = h.result.copy()
        #                 n_.printnode = True
        #
        #             # add node
        #             if n_ not in parent.children:
        #                 parent.children.append(n_)
        #
        #     # recursive call
        #     for n in parent.children:
        #         generate_nodes_rec(n, [hyp for hyp in hypotheses if 'H_' + '.'.join([str(el) for el in hyp.identifiers[:d+1]]) == n.nodetext and d+1 < len(hyp.steps)], d+1)
        #
        # def nodedict(node, hypname) -> dict:
        #     d = {
        #         "edgetext": str(node.edgetext),
        #         "edgetooltip": str(node.edgetttext),
        #         "name": str(node.nodetext),
        #         "tooltip": str(node.nodetttext),
        #         "type": "highlight" if hypname.startswith(node.nodetext) else None,
        #         "showname": node.printnode,
        #         "showedge": True,
        #         "children": []
        #         }
        #     if node.children:
        #        d.update({'children': [nodedict(c, hypname) for c in node.children]})
        #     return d

        # @self.checkthread
        # def query(*_) -> None:
        #     self.bayrob.pushsession.start()
        #
        #     try:
        #         threshold = float(lbl_threshold.text)
        #     except:
        #         threshold = 0.0
        #
        #     # query = dict([(a.name, Interval(a.intervalmin, a.intervalmax)) for a in radar_req.axes])
        #     query = dict([(a.name, ContinuousSet(a.intervalmin, a.intervalmax)) for a in radar_req.axes])
        #
        #     lbl_status.text = 'Querying: threshold={}, params= {}'.format(threshold, ', '.join(['{}: {}'.format(a.name, str(ContinuousSet(a.intervalmin, a.intervalmax))) for a in radar_req.axes]))
        #     logger.info('Querying', {k: str(v) for k, v in query.items()}, threshold, ', '.join(['{}: {}'.format(a.name, str(ContinuousSet(a.intervalmin, a.intervalmax))) for a in radar_req.axes]))
        #
        #     for ti in [x for x in table_candidates.items]:
        #         table_candidates.rmitem(ti)
        #
        #     for c in comp_res.content.children:
        #         c.dispose()
        #
        #     # use bayrob reasoner to query system
        #     self.bayrob.query = query
        #     self.bayrob.threshold = threshold
        #     self.bayrob.models = combo_experiments.selection['trees']
        #     self.bayrob.callback = update
        #     self.bayrob.start()

        # radar_req.on_select += sel
        # btn_query.on_select += query

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

        # CANDIDATES PAGE #
        comp_query = Composite(comp_body)
        comp_query.layout = RowLayout(flexrows=0, halign='fill', valign='fill')
        comp_query.bg = Color('white')
        comp_query.visible = False

        # table_candidates = Table(comp_candidates, halign='fill', valign='fill', headervisible=True,
        #                          colsmoveable=True, check=False)
        #
        # def sort_by_sim(down=None) -> None:
        #     if isinstance(down, bool):
        #         table_candidates.items = sorted(table_candidates.items, key=lambda item: float(item.texts[1]), reverse=down)
        #     else:
        #         table_candidates.items = sorted(table_candidates.items, key=lambda item: float(item.texts[1]), reverse=table_candidates.sortedby[1] == 'down')
        #
        # def sort_by_cand(*_) -> None:
        #     table_candidates.items = sorted(table_candidates.items, key=lambda item: str(item.texts[0]), reverse=table_candidates.sortedby[1] == 'down')
        #
        # col_candidatename = table_candidates.addcol('Candidate', sortable=True, width=100)
        # col_candidatename.on_select += sort_by_cand
        #
        # col_sim = table_candidates.addcol('Probability', sortable=True, width=200)
        # col_sim.on_select += sort_by_sim
        #
        # tcm = Menu(table_candidates, popup=True)
        # mitem_showproc = MenuItem(tcm, 'Show process history of candidate')
        # table_candidates.menu = tcm
        #
        # table_candidates.on_dblclick += showproc
        #
        # mitem_showproc.on_select += showproc

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

        # RESULTS PAGE
        comp_res = ScrolledComposite(comp_body, valign='fill', halign='fill', vscroll=True, hscroll=True)
        #
        # radar_candidates = Radar(comp_res.content, legendtext='', halign='fill', valign='fill', minwidth=self._shell.bounds[2], minheight=self._shell.bounds[3] * 0.7)
        comp_res.visible = False

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

        # TREE PAGE
        comp_tree = Composite(comp_body)
        comp_tree.layout = RowLayout(halign='fill', valign='fill', flexrows=0)

        # tree = RadialTree(comp_tree, css=[res('static/css/charval.css')], halign='fill', valign='fill')
        lbl_tree = Label(comp_tree, halign='fill', valign='fill')

        comp_tree.visible = False

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

        # DOCUMENTATION PAGE #
        comp_docs = Composite(comp_body)
        comp_docs.layout = RowLayout(halign='fill', valign='fill', flexrows=0)

        self.setupdoku()
        Browser(comp_docs, url=config.get('upload', 'dokuloc', fallback=''.join(['http://', session.host, session.location.strip("mobile"), session.runtime.mngr.resources.get('index.html').location])), halign='fill', valign='fill')
        comp_docs.visible = False

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

        # MAIN MENU #
        menuentries = OrderedDict([
            ('Home', comp_home),
            ('Search', comp_search),
            ('Query', comp_query),
            ('Results', comp_res),
            ('Documentation', comp_docs)
        ])

        # LISTENER FUNCTIONS
        def switchpage(_, widget=None) -> None:
            if widget is None:
                _, widget = options_list(self._shell, menuentries)

            # make all widgets invisible and update the layers
            for c in comp_body.children:
                c.visible = False

            # then get the one selected into the foreground
            logger.debug('Moving widget to foreground', widget.id)
            widget.visible = True

        menulabel.on_mousedown += switchpage

        self._shell.show()

    def empty(self, **kwargs) -> None:
        self._shell = Shell(maximized=True, titlebar=False)
        self._shell.bg = Color('transp')
        self._shell.on_resize += self._shell.dolayout

        comp_mainframe = Composite(self._shell.content)
        comp_mainframe.layout = CellLayout(halign='fill', valign='fill')
        Label(comp_mainframe, "I am a placeholder")

        self._shell.show()


def main(ip='127.0.0.1', port=5005) -> None:

    pyrap.register_app(clazz=BayRoBWeb,
                       path='bayrob',
                       name='BayRoB',
                       entrypoints={'desktop': BayRoBWeb.desktop,
                                    'mobile': BayRoBWeb.mobile,
                                    'empty': BayRoBWeb.empty,
                                    },
                       setup=BayRoBWeb.setup,
                       theme=res('static/css/default.css'),
                       default=lambda: 'mobile' if 'mobile' in pyrap.session.client.useragent.lower() else 'desktop',
                       icon=res('static/images/ic_launcher/play_store_512.png')
                       )

    pyrap.run(bindip=ip, port=port)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='BayRoBWeb.')
    parser.add_argument('-p', '--port', type=int, default=5005, help='specify port to run the app on', required=False)
    parser.add_argument('-i', '--ip', type=str, default='127.0.0.1', help='specify port to run the app on', required=False)
    parser.add_argument("-v", "--verbose", dest="verbose", default='debug', type=str, action="store", help="Set verbosity level {debug,info,warning,error,critical}. Default is info.")
    args = parser.parse_args()

    init_loggers(level=args.verbose)
    main(ip='0.0.0.0' if config.getboolean('bayrob', 'public', fallback=False) else args.ip, port=args.port)
