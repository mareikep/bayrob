import argparse
import mimetypes
import os
import shutil
import tempfile
import traceback
from functools import wraps
from pathlib import Path
from typing import Callable, List

import dnutils
import numpy as np
import pandas as pd
import plotly.graph_objects as go
from jpt.base.intervals import ContinuousSet

import pyrap
from bayrob import config
from bayrob.core.astar_jpt import Goal
from bayrob.core.base import Query, Search
from bayrob.logs.logs import init_loggers
from bayrob.utils import locs
from bayrob.utils.constants import bayroblogger, bayrobjsonlogger, obstacles, obstacle_kitchen_boundaries, querypresets, \
    searchpresets
from bayrob.utils.plotlib import build_constraints, fig_to_file, plot_heatmap, plot_data_subset, plot_path, \
    plot_pos, plot_dir, gendata
from bayrob.utils.utils import res, urlable, fmt
from bayrob.web.thread import BayRoBSessionThread
from jpt.distributions.univariate import Bool, Numeric
from pyrap import session
from pyrap.layout import RowLayout, ColumnLayout, CellLayout, StackLayout
from pyrap.ptypes import Color, Image, Pixels, px
from pyrap.pwt.svg.svg import SVG
from pyrap.widgets import Shell, Composite, Label, Button, Separator, TabFolder, Browser, Combo, Edit, Group, Link, \
    SashMenuComposite, ScrolledComposite

if config.getboolean('bayrob', 'smoothed', fallback=False):
    pass
else:
    pass

logger = dnutils.getlogger(bayroblogger)
jsonlogger = dnutils.getlogger(bayrobjsonlogger)


class BayRoBWeb:
    def __init__(self):
        self.bayrob = BayRoBSessionThread(self)
        self.bayrob.adddatapath([os.path.join(locs.examples, 'demo', d) for d in os.listdir(os.path.join(locs.examples, 'demo'))])
        self.wnd_query_model = None
        self.wnd_search = None
        self.qo = Query()
        self.asr = Search()
        self.uploaddir = None
        self.menu_width = 250
        self.wnd_wait = None

    @staticmethod
    def setup(application) -> None:
        '''
        Loads ontology into webapp. For later use
        :param application:     The current application
        :return:                nothing
        '''
        BayRoBWeb.compiledoku()

    @staticmethod
    def compiledoku() -> None:
        '''
        Compiles the documentation for this software in html, such that the most recent version
        is available in the documentation tab (browser)
        :return:
        '''
        if config.get('bayrob', 'mode', fallback='release') != 'debug':
            os.system("make -s html -C {} SPHINXOPTS=-Q".format(locs.doc))
            # os.system("make clean -C {0} && make html -C {0}".format(locs.doc))

    @staticmethod
    def setupdoku() -> None:
        '''
        Registers all the files generated by `compiledoku()' to make them available in the browser.
        :return:
        '''
        for root, _, files in os.walk(os.path.join(locs.doc, 'build', 'html')):
            for f in files:
                if any([f.endswith(ext) for ext in ['.swp', '.inv', '.map']]) or not os.path.splitext(f)[1]: continue
                fname = os.path.join(root.lstrip(os.path.join(locs.doc, 'build', 'html')), f)
                try:
                    with open(os.path.join(root, f), 'rb') as fi:
                        session.runtime.mngr.resources.registerf(fname, mimetypes.guess_type(fname)[0], fi, force=True)
                except UnicodeDecodeError:
                    logger.error('Could not register file', fname, '. unicodeerror')

    def checkthread(self, f) -> Callable:
        @wraps(f)
        def decorated(*args, **kwargs):
            if self.bayrob.is_alive():
                self.bayrob.join()
            self.bayrob = BayRoBSessionThread(self)
            self.bayrob.adddatapath([os.path.join(locs.examples, 'demo', d) for d in os.listdir(os.path.join(locs.examples, 'demo'))])
            return f(*args, **kwargs)
        return decorated

    def initialize(self) -> None:
        '''Set up important configurations for the session such as the default upload folder.

        :return:
        '''
        ufldr = config.get('upload', 'uploadfldr', fallback=tempfile.gettempdir())

        if not os.path.exists(ufldr):
            os.mkdir(ufldr)

        dirname = tempfile.mkdtemp(prefix='bayrob', dir=ufldr)
        self.uploaddir = os.path.join(ufldr, dirname)
        logger.debug('Setting upload folder to', self.uploaddir)

        def cleanup(*_):
            if os.path.exists(os.path.join(ufldr, dirname)):
                shutil.rmtree(os.path.join(ufldr, dirname))

        session.on_kill += cleanup

    def presets(
            self,
            qtype
    ):
        if qtype == 'queryjpt':
            return querypresets
        elif qtype == 'search':
            return searchpresets
        elif qtype == "plotvars":
            return {
                'perception.tree': {
                    f'x_in x y_in': [self.bayrob.models["perception.tree"].varnames["x_in"],
                                     self.bayrob.models["perception.tree"].varnames["y_in"]],
                    f'xdir_in x ydir_in': [self.bayrob.models["perception.tree"].varnames["xdir_in"],
                                           self.bayrob.models["perception.tree"].varnames["ydir_in"]],
                    **{
                        k: v for k, v in self.bayrob.models['perception.tree'].varnames.items() if
                        k not in ['x_in', 'y_in', 'xdir_in', 'ydir_in']
                    }
                },
                'move.tree': {
                    f'x_in x y_in': [self.bayrob.models["move.tree"].varnames["x_in"],
                                     self.bayrob.models["move.tree"].varnames["y_in"]],
                    f'xdir_in x ydir_in': [self.bayrob.models["move.tree"].varnames["xdir_in"],
                                           self.bayrob.models["move.tree"].varnames["ydir_in"]],
                    f'x_out x y_out': [self.bayrob.models["move.tree"].varnames["x_in"],
                                       self.bayrob.models["move.tree"].varnames["y_in"]],
                    **{
                        k: v for k, v in self.bayrob.models['move.tree'].varnames.items() if
                        k not in ['x_in', 'y_in', 'xdir_in', 'ydir_in', 'x_out', 'y_out']
                    }
                },
                'turn.tree': {
                    f'xdir_in x ydir_in': [self.bayrob.models["turn.tree"].varnames["xdir_in"],
                                           self.bayrob.models["turn.tree"].varnames["ydir_in"]],
                    f'xdir_out x ydir_out': [self.bayrob.models["turn.tree"].varnames["xdir_out"],
                                             self.bayrob.models["turn.tree"].varnames["ydir_out"]],
                    **{
                        k: v for k, v in self.bayrob.models['turn.tree'].varnames.items() if
                        k not in ['xdir_in', 'ydir_in', 'xdir_out', 'ydir_out']
                    }
                },
                'pr2.tree': {
                    f't_x x t_y': [self.bayrob.models["pr2.tree"].varnames["t_x"],
                                   self.bayrob.models["pr2.tree"].varnames["t_y"]],
                    **{
                        k: v for k, v in self.bayrob.models['pr2.tree'].varnames.items() if
                        k not in ['t_x', 't_y', 't_z', 'duration', 'angle_z']
                    }
                }
            }
        else:
            return {}

    # = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
    # DESKTOP VERSION
    # = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
    def desktop(self, **kwargs) -> None:
        self.initialize()

        self._shell = Shell(maximized=True, titlebar=False)
        self._shell.bg = Color('transp')
        self._shell.on_resize += self._shell.dolayout

        comp_mainframe = Composite(self._shell.content)
        comp_mainframe.layout = RowLayout(halign='fill', valign='fill', flexrows={1: 1}, vspace=0)

        # * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        # HEADER
        # * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        comp_header = Composite(comp_mainframe)
        comp_header.layout = ColumnLayout(halign='fill', minheight=px(60), flexcols=1)
        comp_header.css = 'navbar'
        comp_header.bgimg = Image(res('static/images/dark-metal-texture_rot.png'))

        # LOGOS #
        _logo = Image(res('static/images/logo.png')).resize(height=Pixels(55))
        logo = Label(comp_header, padding=px(0), img=_logo, valign='center')
        logo.bg = Color('transp')
        Label(comp_header)
        easelogo = Label(comp_header, img=Image(res('static/images/open-ease-logo.png')).resize(height=Pixels(40)), valign='center', halign='center')
        easelogo.bg = Color('transp')
        ailogo = Label(comp_header, img=Image(res('static/images/ai_logo_white.png')).resize(height=Pixels(40)), valign='center', halign='center')
        ailogo.bg = Color('transp')
        unilogo = Label(comp_header, img=Image(res('static/images/uni-bremen.png')).resize(height=Pixels(40)), valign='center', halign='center')
        unilogo.bg = Color('transp')

        # * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        # WAIT LOGO
        # * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

        # initialize wait logo but hide it so it can be shown/hidden when query is running/finished
        self.wnd_wait = Shell(parent=self._shell, titlebar=False, border=False, resize=False, modal=False, halign='right', valign='bottom')
        self.wnd_wait.create_content()
        self.wnd_wait.bg = Color('transp')
        self.wnd_wait.content.bg = Color('transp')
        wait_imgsize = 85
        wait_padding = 30
        w = session.runtime.display.width.value
        h = session.runtime.display.height.value
        self.wnd_wait.bounds = w-wait_imgsize-wait_padding, h-wait_imgsize-wait_padding, wait_imgsize, wait_imgsize

        lbl_wnd = Label(self.wnd_wait.content, img=Image(res('static/images/wait_steelblue.gif')), valign='fill', halign='fill')
        lbl_wnd.bg = Color('transp')

        def movewait() -> None:
            w = session.runtime.display.width.value
            h = session.runtime.display.height.value
            self.wnd_wait.bounds = w - wait_imgsize - wait_padding, h - wait_imgsize - wait_padding, wait_imgsize, wait_imgsize

        self.wnd_wait.on_resize += self.wnd_wait.dolayout
        self._shell.on_resize += movewait
        self.wnd_wait.show()
        self.wnd_wait.visible = False

        # * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        # TABFOLDER
        # * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        tabfldr_body = TabFolder(comp_mainframe, tabpos='bottom', halign='fill', valign='fill')
        tabfldr_body.css = 'navbar'

        Separator(comp_mainframe, horizontal=True, halign='fill')

        comp_status = Composite(comp_mainframe, text='Status')
        comp_status.layout = ColumnLayout(halign='fill', valign='fill', flexcols=1)

        Label(comp_status, text='Status:', halign='fill', valign='fill')
        lbl_status = Edit(comp_status, text='OK', multiline=True, halign='fill', valign='fill', border=False, minheight=20)
        Link(comp_status, text="<a href='http://ai.uni-bremen.de/doku.php?id=impressum' target='_blank'>Disclaimer</a>", markup=True, padding=5, halign='fill', valign='fill')

        # BAYROB TAB #
        da_stack = tabfldr_body.addtab('BayRoB', idx=2)
        da_stack.content.layout = StackLayout(halign='fill', valign='fill')

        # * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        # BAYROB MENU
        # * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        da_sash_menu = SashMenuComposite(da_stack.content, self._shell, color='#5882B5', mwidth=self.menu_width)
        da_comp_menu = da_sash_menu.menu
        da_comp_menu.layout.flexrows = {2: 1}

        btn_query_model = Button(da_comp_menu, text='Query model', minwidth=px(self.menu_width - 50), halign='fill', valign='fill')
        btn_search = Button(da_comp_menu, text='Search', minwidth=px(self.menu_width - 50), halign='fill', valign='fill')

        Label(da_comp_menu, text='', valign='fill', halign='fill')
        Separator(da_comp_menu, horizontal=True, halign='fill')

        btn_download = Button(da_comp_menu, text='Download', halign='fill', valign='fill', minwidth=px(self.menu_width - 50))
        btn_download.enabled = False
        btn_clearviz = Button(da_comp_menu, text='Clear', halign='fill', valign='fill', minwidth=px(self.menu_width - 50))

        # * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        # BAYROB
        # * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        comp_analysis = Composite(da_sash_menu.content)
        comp_analysis.layout = RowLayout(flexrows={0: 5, 2: 1}, halign='fill', valign='fill', padding_left=15)

        grp_analysisviz = Group(comp_analysis, 'Visualization')
        grp_analysisviz.layout = RowLayout(halign='fill', valign='fill', flexrows=0, padding_left=12)
        comp_analysisviz = Composite(grp_analysisviz)
        comp_analysisviz.layout = CellLayout(halign='fill', valign='fill', padding_top=10)
        bglogo = Label(comp_analysisviz, img=Image(res('static/images/logo.png')).resize(height=Pixels(150)), valign='center', halign='center')
        bglogo.bg = Color(html='#3b296a99', alpha=.4)

        Separator(comp_analysis, horizontal=True, halign='fill')

        comp_analysistext = Group(comp_analysis, 'Results')
        comp_analysistext.layout = ColumnLayout(halign='fill', valign='fill', flexcols=0, padding_left=12)
        lbl_textresults = Edit(comp_analysistext, text='', multiline=True, border=False, halign='fill', valign='fill')

        def clear(*_) -> None:
            # clear previously loaded visualizations
            for c in comp_analysisviz.children:
                c.dispose()

            bglogo = Label(comp_analysisviz, img=Image(res('static/images/logo.png')).resize(height=Pixels(150)), valign='center', halign='center')
            bglogo.bg = Color(html='#3b296a99', alpha=.4)

            # clear text results
            lbl_textresults.text = ''
            self._shell.dolayout()

        def download_visualization(*_) -> None:
            # download pdf of conditional tree generated by query model call

            fn_tree_dists = os.path.join(self.uploaddir, f"conditional_tree_dists.pdf")
            if not os.path.isfile(fn_tree_dists):
                from svglib.svglib import svg2rlg
                from reportlab.graphics import renderPDF

                drawing = svg2rlg(fn_tree_dists.replace(".pdf", ".svg"))
                renderPDF.drawToFile(drawing, fn_tree_dists)

            try:
                if os.path.isfile(fn_tree_dists):
                    logger.debug('Downloading existing file', fn_tree_dists)
                    session.runtime.download(fn_tree_dists, 'application/pdf')
                else:
                    lbl_status.text = 'No visualization available for download.'
            except:
                traceback.print_exc()
                session.runtime.download(fn_tree_dists, 'application/pdf', force=True)

        def suggestions(
                var,
                mean=False,
                tolerance=False
        ):
            # return string of value suggestions for variable selection in query model window
            if var.domain is Numeric:
                if mean:
                    return "mean value, e.g. 3"
                elif tolerance:
                    return "variance, e.g. 0.01"
                else:
                    return "range/interval, e.g. [3, 50] or [10, 20["
            if var.domain is Bool:
                return "anything Boolean-like, e.g. True, true, y, yes, 1, ..."
            else:
                return f"comma-separated, e.g. {', '.join(list(var.domain.values)[:5])}"

        def parseval(
                val,
                var=None,
                onlysets=False
        ):
            # transform entered values into valid query values for that type of variable (both query model and search)
            try:
                if var.domain is Numeric:
                    return ContinuousSet.fromstring(val)
                elif var.domain is Bool:
                    if onlysets:
                        return set(map(lambda x: x.strip(), val.split(',')))
                    return val.lower() in ['true', '1', 't', 'y', 'yes', 'yeah', 'yup', 'certainly', 'uh-huh']
                else:
                    return set(map(lambda x: x.strip(), val.split(',')))
            except:
                return val

        btn_clearviz.on_select += clear
        btn_download.on_select += download_visualization

        # DOCUMENTATION TAB #
        comp_docs = tabfldr_body.addtab('Documentation', idx=2)
        comp_docs.layout = CellLayout(halign='fill', valign='fill')

        comp_ = Composite(comp_docs.content)
        comp_.layout = CellLayout(halign='fill', valign='fill')

        self.setupdoku()
        Browser(comp_, url=config.get('upload', 'dokuloc', fallback=''.join(['http://', session.host, session.location, session.runtime.mngr.resources.get('index.html').location])), halign='fill', valign='fill')

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

        def plot_ground_truth(
                df,
                limx,
                limy,
                plot,
                plottype,
                pdfvars
        ):
            # return plot of ground truth (bar chart or scatter plot)
            gt = go.Figure()

            gt_ = plot_data_subset(
                df,
                xvar=plot[0].name if isinstance(plot, list) and len(plot) > 1 else plot.name,
                yvar=plot[1].name if isinstance(plot, list) and len(plot) > 1 else None,
                constraints=pdfvars,
                limx=limx,
                limy=limy,
                save=None,
                show=False,
                color='rgb(0,104,180)',
                plot_type=plottype
            )
            if gt_ is not None:
                gt.layout = gt_.layout
                gt.add_traces(gt_.data)

            return gt

        def plot_dist_heatmap(
                data,
                limx,
                limy
        ):
            # return plot of distribution (heatmap)
            dist = go.Figure()

            # plot heatmap
            dist_ = plot_heatmap(
                xvar='x',
                yvar='y',
                data=data,
                limx=limx,
                limy=limy,
                # limz=(0, 1),
                show=False,
                save=None,
                fun="heatmap"
            )

            if dist_ is not None:
                dist.layout = dist_.layout
                dist.add_traces(dist_.data)

            return dist

        def plot_dist_bar(
                posterior,
                plot
        ):
            # return plot of distribution (bar chart)
            plot_ = posterior[plot].plot(
                    view=False,
                    title=False,  # f'Dist: {plot}<br>(Query): {querystring}',
                    alphabet=True,
                    color='rgb(59, 41, 106)',
                    xvar=plot.name
            )
            return plot_

        def gendata_path(
                xvar: str,
                yvar: str,
                path: List
        ):
            # generate data for path plot (result of search)
            d = [
                (
                    np.mean([s[xvar].mpe()[0].lower, s[xvar].mpe()[0].upper]),  # x
                    np.mean([s[yvar].mpe()[0].lower, s[yvar].mpe()[0].upper]),  # y
                    np.mean([s['xdir_in'].mpe()[0].lower, s['xdir_in'].mpe()[0].upper]),  # dx
                    np.mean([s['ydir_in'].mpe()[0].lower, s['ydir_in'].mpe()[0].upper]),  # dy
                    f'Step {i}',  # step
                    f'<b>Step {i}</b><br>'
                    f'<b>{"ROOT" if s.leaf is None or s.tree is None else f"{s.tree}-Leaf#{s.leaf}"}</b><br>'
                    f'<b>MPEs:</b><br>'
                    f'{"<br>".join(f"<i>{k}:</i> {fmt(v)}" for k, v in s.items())}<br>'
                    f'<b>Expectations:</b><br>'
                    f'{"<br>".join(f"<i>{k}:</i> {fmt(v.expectation())}" for k, v in s.items())}<br>',
                    1  # size
                )
                for i, s in enumerate(path) if not isinstance(s, Goal)
            ]

            return d

        def plot_search_results(
                self
        ) -> None:
            # a succeeded search is visualized in terms of a) a plot of the found path, b) an (animated) plot of the
            # position distribution and c) an (animated) plot of the direction distribution

            self.wnd_wait.visible = False
            btn_search.enabled=True
            btn_query_model.enabled=True

            result = self.bayrob.result
            path = result.result

            if not result.success:
                logger.warning(f'There was a problem: Error: {result.error}. Message: {result.message}')
                lbl_status.text = "Success!" if self.bayrob.result.success else f"Failed: {result.error}"
                lbl_textresults.text = result.message
                self.bayrob.result.clear()
                self._shell.dolayout()
                return
            else:
                logger.info(f'Search {self.bayrob.query} finished successfully.')

            # create containers for search path visualization
            for c in comp_analysisviz.children:
                c.dispose()

            comp_viz_search = Composite(comp_analysisviz)
            comp_viz_search.layout = ColumnLayout(halign='fill', valign='fill', equalwidths=True)

            comp_viz_path = Composite(comp_viz_search)
            comp_viz_path.layout = CellLayout(halign='fill', valign='fill')

            # for dists plots
            comp_viz_dists = Composite(comp_viz_search)
            comp_viz_dists.layout = RowLayout(halign='fill', valign='fill', equalheights=True)

            # for dist pos
            comp_viz_pos = Composite(comp_viz_dists)
            comp_viz_pos.layout = CellLayout(halign='fill', valign='fill')

            # for dist dir
            comp_viz_dir = Composite(comp_viz_dists)
            comp_viz_dir.layout = CellLayout(halign='fill', valign='fill')

            d = gendata_path(
                xvar='x_in',
                yvar='y_in',
                path=path
            )

            fig_path = plot_path(
                xvar='x_in',
                yvar='y_in',
                p=path,
                d=d,
                obstacles=[obstacle_kitchen_boundaries] + obstacles
            )

            data_pos = [
                gendata(
                    'x_in',
                    'y_in',
                    s,
                    {},
                ) for i, s in enumerate(path) if not isinstance(s, Goal)
            ]

            fig_pos = plot_pos(
                path=path,
                d=data_pos,
                limx=(0, 100),
                limy=(0, 100)
            )

            data_dir = [
                gendata(
                    'xdir_in',
                    'ydir_in',
                    s,
                    {},
                ) for i, s in enumerate(path) if not isinstance(s, Goal)
            ]

            fig_dir = plot_dir(
                path=path,
                d=data_dir,
                limx=(-3, 3),
                limy=(-3, 3)
            )

            # save plot to html file
            fname_path = os.path.join(self.uploaddir, f"search-path.html")
            fname_pos = os.path.join(self.uploaddir, f"search-pos.html")
            fname_dir = os.path.join(self.uploaddir, f"search-dir.html")

            fig_to_file(fig_path, fname_path, ftypes=['.svg', '.html'])
            fig_to_file(fig_pos, fname_pos, ftypes=['.svg', '.html'])
            fig_to_file(fig_dir, fname_dir, ftypes=['.svg', '.html'])

            # register file to make it available as resource
            for fn, comp in zip([fname_path, fname_pos, fname_dir], [comp_viz_path, comp_viz_pos, comp_viz_dir]):
                resname = f'resource/static/image/{Path(fn).stem}.html'
                with open(fn, 'rb') as f:
                    res = session.runtime.mngr.resources.registerf(resname, 'text/html', f, force=True)
                    u_ = f'http://{session.host}{session.location}{res.location}'

                    # display plot in visualization
                    Browser(
                        comp,
                        url=u_,
                        halign='fill',
                        valign='fill'
                    )

            lbl_status.text = "Success!" if self.bayrob.result.success else "Failed!"
            lbl_textresults.text = str(self.bayrob.result)

            self.bayrob.result.clear()
            self._shell.dolayout()

        def plot_query_results(
                self
        ) -> None:
            # a succeeded query is visualized in terms of a) a plot of ground truth (scatter or normalized bar plot)
            # and b) a plot of the distribution (heatmap or normalized bar plot) for each plot variable enterd in the
            # query window and c) a tree plot of the conditional tree (without distribution images). A new window is
            # opened for each ground truth/distribution plot pair. The conditional tree can be downloaded as PDF file
            # (including distribution images)

            self.wnd_wait.visible = False
            btn_search.enabled = True
            btn_query_model.enabled = True

            result = self.bayrob.result
            cond, post = result.result

            if not result.success:
                logger.warning(f'There was a problem: Error: {result.error}. Message: {result.message}')
                lbl_status.text = "Success!" if self.bayrob.result.success else f"Failed: {result.error}"
                lbl_textresults.text = result.message
                self.bayrob.result.clear()
                self._shell.dolayout()
                return
            else:
                logger.info(f'Querying {self.bayrob.query} finished successfully.')

            # plot conditional tree
            fn_tree = os.path.join(self.uploaddir, f"conditional_tree.svg")
            cond.plot(
                plotvars=None,
                filename=f'conditional_tree',
                directory=self.uploaddir,
                leaffill='#CCDAFF',
                nodefill='#768ABE',
                alphabet=True,
                view=False
            )

            cond.plot(
                plotvars=list(cond.variables),
                filename=f'conditional_tree_dists',
                directory=self.uploaddir,
                leaffill='#CCDAFF',
                nodefill='#768ABE',
                alphabet=True,
                view=False
            )

            # plot conditional tree and visualize it in main window (downloadable through download button in menu)
            for c in comp_analysisviz.children:
                c.dispose()

            c = ScrolledComposite(comp_analysisviz, valign='fill', halign='fill', hscroll=True, vscroll=True)
            s = SVG(c.content, svg=fn_tree, halign='fill', valign='fill')
            s.maxheight(comp_analysisviz.bounds[3])
            s.maxwidth(comp_analysisviz.bounds[2])

            btn_download.enabled = True

            # plot ground truth/distribution pairs (separate window for each variable)
            df = pd.read_parquet(self.bayrob.datasets[self.qo.modelname])

            for plot in self.qo.plotvars:
                if isinstance(plot, list):
                    if all([v.name.endswith('_in') for v in plot]):
                        limx = (0, 100)
                        limy = (0, 100)
                    else:
                        limx = (-2, 2)
                        limy = (-2, 2)

                    # data generation for distribution plot
                    x = np.linspace(*limx, max(50, int((limx[1] - limx[0]) * 2)))
                    y = np.linspace(*limy, max(50, int((limy[1] - limy[0]) * 2)))

                    X, Y = np.meshgrid(x, y)
                    Z = np.array([cond.pdf(cond.bind({plot[0]: x, plot[1]: y})) for x, y, in zip(X.ravel(), Y.ravel())]).reshape(X.shape)
                    lbl = np.full(Z.shape, '<br>'.join([f'{vname}: {val}' for vname, val in self.qo.query.items()]))

                    data = pd.DataFrame(
                        data=[[x, y, Z, lbl]],
                        columns=['x', 'y', 'z', 'lbl']
                    )

                    gt = plot_ground_truth(df, limx, limy, plot, 'scatter', {k.name: v for k, v in self.qo.query.items()})
                    dist = plot_dist_heatmap(data, limx, limy)
                else:
                    gt = plot_ground_truth(df, None, (0, 1), plot, 'histogram', {k.name: v for k, v in self.qo.query.items()})
                    dist = plot_dist_bar(post, plot)

                # save plot to html file
                pt = urlable('X'.join([p.name for p in plot]) if isinstance(plot, list) else plot.name)
                fname_gt = os.path.join(self.uploaddir, f"gt-{pt}.html")
                fname_dist = os.path.join(self.uploaddir, f"dist-{pt}.html")

                fig_to_file(gt, fname_gt, ftypes=['.svg', '.html'])
                fig_to_file(dist, fname_dist, ftypes=['.svg', '.html'])

                # register file to make it available as resource
                urls = []
                for fn in [fname_gt, fname_dist]:
                    resname = f'resource/static/image/{Path(fn).stem}.html'
                    with open(fn, 'rb') as f:
                        res = session.runtime.mngr.resources.registerf(resname, 'text/html', f, force=True)
                        u_ = f'http://{session.host}{session.location}{res.location}'
                        urls.append(u_)

                # display plot in separate windows
                open_plot_window(urls, pt)

            self.bayrob.result.clear()
            self._shell.dolayout()

        def open_plot_window(
                urls,
                pvars
        ):
            # display ground truth/distribution plot pair in separate window (plotly html in Browser widget)
            wnd_plot = Shell(parent=self._shell, title=pvars,
                             border=True, btnclose=True, btnmin=True,
                             resize=True, modal=False, titlebar=True)
            wnd_plot.on_resize += wnd_plot.dolayout

            w = min(2100., 0.8 * session.runtime.display.width.value)
            h = min(1100., 0.8 * session.runtime.display.height.value)
            wnd_plot.bounds = self._shell.width.value / 2 - w / 2, self._shell.height.value / 2 - h / 2, w, h

            comp_main = Composite(wnd_plot.content, hscroll=True, vscroll=True)
            comp_main.layout = RowLayout(halign='fill', valign='fill', flexrows=1)

            comp_header = Composite(comp_main, hscroll=True, vscroll=True)
            comp_header.layout = ColumnLayout(halign='fill', valign='fill', equalwidths=True)

            Label(comp_header, text='<b>Ground Truth</b>', markup=True, halign='center', valign='center')
            Label(comp_header, text='<b>Distribution</b>', markup=True, halign='center', valign='center')

            comp = Composite(comp_main, hscroll=True, vscroll=True)
            comp.layout = ColumnLayout(halign='fill', valign='fill', flexcols={0: 1, 2: 1})

            Browser(
                comp,
                url=urls[0],
                halign='fill',
                valign='fill'
            )

            Separator(comp, vertical=True, valign='fill')

            Browser(
                comp,
                url=urls[1],
                halign='fill',
                valign='fill'
            )

            wnd_plot.show()

            lbl_status.text = "Success!" if self.bayrob.result.success else "Failed!"
            lbl_textresults.text = str(self.bayrob.result)

            self._shell.dolayout()

        @self.checkthread
        def search(*_) -> None:
            # trigger BayRoB search/plan refinement

            # clear previous visualizations and messages and disable controls to prevent interferences, move menu
            # out of view
            clear()
            self.wnd_search.close()
            btn_search.enabled = False
            btn_query_model.enabled = False
            if da_sash_menu.visible:
                da_sash_menu.togglemenu()

            self.bayrob.pushsession.start()

            lbl_status.text = f'Searching...'
            lbl_textresults.text = f"Searching path: {str(self.asr)}"
            logger.info(f'Searching path: {str(self.asr)}')

            # use bayrob reasoner to search path
            self.bayrob.query = self.asr
            self.bayrob.runfunction = 'astar'

            self.bayrob.callback = plot_search_results
            w = session.runtime.display.width.value
            h = session.runtime.display.height.value
            self.wnd_wait.bounds = w - wait_imgsize - wait_padding, h - wait_imgsize - wait_padding, wait_imgsize, wait_imgsize
            self.wnd_wait.visible = True
            self.bayrob.start()

            self._shell.dolayout()

        @self.checkthread
        def query_jpt(*_) -> None:
            # trigger BayRoB query for single model

            # clear previous visualizations and messages and disable controls to prevent interferences, move menu
            # out of view
            clear()
            self.wnd_query_model.close()
            btn_search.enabled = False
            btn_query_model.enabled = False
            if da_sash_menu.visible:
                da_sash_menu.togglemenu()

            self.bayrob.pushsession.start()

            lbl_status.text = f'Querying...'
            lbl_textresults.text = f"Querying: {str(self.qo)}"
            logger.info(f'Querying: {str(self.qo)}')

            # use bayrob reasoner to query single model
            self.bayrob.query = self.qo

            self.bayrob.runfunction = 'queryjpt'
            self.bayrob.callback = plot_query_results
            w = session.runtime.display.width.value
            h = session.runtime.display.height.value
            self.wnd_wait.bounds = w - wait_imgsize - wait_padding, h - wait_imgsize - wait_padding, wait_imgsize, wait_imgsize
            self.wnd_wait.visible = True
            self.bayrob.start()

            self._shell.dolayout()

        def search_dialog(*_) -> None:
            # open search window which allows to define init and goal state (or load presets) and trigger
            # search/plan refinement
            if self.wnd_search is not None and not self.wnd_search.disposed:
                # make window visible again and put focus on it
                self.wnd_search.visible = True
                self.wnd_search.focus()
            else:
                self.wnd_search = Shell(parent=self._shell, title='BayRoB Search',
                                             border=True, btnclose=True, btnmin=True,
                                             resize=True, modal=False, titlebar=True)
                self.wnd_search.on_resize += self.wnd_search.dolayout

                w = min(800., 0.8 * session.runtime.display.width.value)
                h = min(600., 0.7 * session.runtime.display.height.value)
                self.wnd_search.bounds = self._shell.width.value/2 - w/2, self._shell.height.value/2 - h/2, w, h
                comp = Composite(self.wnd_search.content, hscroll=True, vscroll=True)
                comp.layout = RowLayout(halign='fill', valign='fill', flexrows={2: 1, 7: 1})

                # ==================================================================

                Label(comp, text='Specify goal', valign='center', halign='fill')
                # multiple combos to select variables from tree
                # contains rows of triples (-, combovariable, text value)
                comp_goalsettings = Composite(comp)
                comp_goalsettings.layout = RowLayout(halign='fill', valign='fill', equalheights=True)

                # buttons to add new queryrow and remove entire query block
                Label(comp, text='', valign='fill', halign='fill')
                comp2 = Composite(comp)
                comp2.layout = ColumnLayout(halign='left', valign='fill')
                btn_add_queryvar = Button(comp2, '+')
                btn_clear_vars = Button(comp2, 'clear query')
                edit_query = Label(comp2, text="", valign='center', halign='fill')
                Separator(comp, horizontal=True, halign='fill')

                # ==================================================================

                Label(comp, text='Specify init state', valign='center', halign='fill')
                comp_initsettings = Composite(comp)
                comp_initsettings.layout = RowLayout(halign='fill', valign='fill', equalheights=True)

                # buttons to add new queryrow and remove entire query block
                Label(comp, text='', valign='fill', halign='fill')
                comp3 = Composite(comp)
                comp3.layout = ColumnLayout(halign='left', valign='fill')
                btn_add_initvar = Button(comp3, '+')
                btn_clear_initvars = Button(comp3, 'clear init vars')
                edit_init = Label(comp3, text="", valign='center', halign='fill')

                # ==================================================================

                comp_preset = Composite(comp)
                comp_preset.layout = ColumnLayout(valign='fill', halign='fill', flexcols=1)
                Label(comp_preset, text='Load preset', valign='center', halign='fill')
                combo_presets = Combo(comp_preset, editable=False, items=self.presets(qtype='search'), minwidth=px(200), halign='fill',valign='fill')

                # ==================================================================

                btn_execute_query = Button(comp, 'Search', valign='fill', halign='fill')

                # ==================================================================

                self.asr = Search()

                allvars = self.bayrob.models['move.tree'].variables + self.bayrob.models['turn.tree'].variables + \
                          self.bayrob.models['perception.tree'].variables + self.bayrob.models['pr2.tree'].variables
                allvars_ = {v.name: v for v in allvars}

                def add_goalvar_row(*_):
                    # goal state specification:
                    # add row containing dropdown box for variable selection (all variables from all models), value
                    # specification, (tolerance specification for Numeric variables) and button to remove entire row

                    comp_tmp = Composite(comp_goalsettings)
                    comp_tmp.layout = ColumnLayout(halign='fill', valign='fill', flexcols=[0, 1])
                    combo_vars = Combo(comp_tmp, editable=False, items=allvars, minwidth=px(200), halign='fill', valign='fill')
                    lbl_vals = Edit(comp_tmp, message="", editable=True, minwidth=px(200), valign='fill', halign='fill')
                    lbl_tol = Edit(comp_tmp, message="", editable=True, minwidth=px(200), valign='fill', halign='fill')
                    lbl_tol.enabled = False
                    btn_rem_queryvar = Button(comp_tmp, '-', valign='fill', halign='fill')

                    def add_goalvar(*_) -> None:
                        # add variable represented by row to goal state specification

                        self.asr.goal[combo_vars.selection] = parseval(
                            lbl_vals.text,
                            var=combo_vars.selection,
                            onlysets=True
                        )
                        self.asr.goal_tolerances[combo_vars.selection] = lbl_tol.text
                        updatequery()

                    def rem_goalvar(*_) -> None:
                        # remove variable represented by row from goal state specification

                        if combo_vars.selection in self.asr.goal and self.asr.goal[combo_vars.selection] == lbl_vals.text:
                            del self.asr.goal[combo_vars.selection]
                        if combo_vars.selection in self.asr.goal_tolerances and self.asr.goal_tolerances[combo_vars.selection] == lbl_tol.text:
                            del self.asr.goal_tolerances[combo_vars.selection]
                        comp_tmp.dispose()
                        updatequery()

                    def update_suggestions(*_) -> None:
                        # add message with suggestions for possible values depending on selected variable

                        lbl_vals.message = suggestions(combo_vars.selection)
                        lbl_tol.enabled = combo_vars.selection.domain is Numeric
                        self.wnd_search.dolayout()

                    btn_rem_queryvar.on_select += rem_goalvar
                    combo_vars.on_select += update_suggestions
                    lbl_vals.on_modify += add_goalvar
                    self.wnd_search.dolayout()

                def add_initvar_row(*_):
                    # init state specification:
                    # add row containing dropdown box for variable selection (all variables from all models), value
                    # specification, (tolerance specification for Numeric variables) and button to remove entire row

                    comp_tmp = Composite(comp_initsettings)
                    comp_tmp.layout = ColumnLayout(halign='fill', valign='fill', flexcols=[0, 1])
                    combo_vars = Combo(comp_tmp, editable=False, items=allvars, minwidth=px(200), halign='fill', valign='fill')
                    lbl_vals = Edit(comp_tmp, message="", editable=True, minwidth=px(200), valign='fill', halign='fill')
                    lbl_tol = Edit(comp_tmp, message="", editable=True, minwidth=px(200), valign='fill', halign='fill')
                    lbl_tol.enabled = False
                    btn_rem_queryvar = Button(comp_tmp, '-', valign='fill', halign='fill')

                    def add_initvar(*_) -> None:
                        # add variable represented by row to init state specification

                        self.asr.init[combo_vars.selection] = parseval(
                            lbl_vals.text,
                            var=combo_vars.selection,
                            onlysets=True
                        )
                        self.asr.init_tolerances[combo_vars.selection] = lbl_tol.text
                        updatequery()

                    def rem_initvar(*_) -> None:
                        # remove variable represented by row from init state specification

                        if combo_vars.selection in self.asr.init and self.asr.init[combo_vars.selection] == lbl_vals.text:
                            del self.asr.init[combo_vars.selection]
                        if combo_vars.selection in self.asr.init_tolerances and self.asr.init_tolerances[combo_vars.selection] == lbl_tol.text:
                            del self.asr.init[combo_vars.selection]
                        comp_tmp.dispose()
                        updatequery()

                    def update_suggestions(*_) -> None:
                        # add message with suggestions for possible values depending on selected variable

                        lbl_vals.message = suggestions(combo_vars.selection)
                        lbl_tol.enabled = combo_vars.selection.domain is Numeric
                        self.wnd_search.dolayout()

                    btn_rem_queryvar.on_select += rem_initvar
                    combo_vars.on_select += update_suggestions
                    lbl_vals.on_modify += add_initvar
                    self.wnd_search.dolayout()

                def updatequery(*_):
                    # update the text summary of query so far

                    edit_query.text = ', '.join([f'{k}: {v}' for k, v in self.asr.goal.items()])
                    edit_init.text = ', '.join([f'{k}: {v}' for k, v in self.asr.init.items()])
                    self.wnd_search.dolayout()

                def loadpreset(*_):
                    # update init and goal state according to predefined settings, update summary texts

                    preset = combo_presets.selection
                    clear_goal()
                    clear_init()

                    self.asr.init = {allvars_[k]: v for k, v in preset['init'].items()}
                    self.asr.init_tolerances = {allvars_[k]: v for k, v in preset['init_tolerances'].items()}
                    self.asr.goal = {allvars_[k]: v for k, v in preset['goal'].items()}
                    self.asr.goal_tolerances = {allvars_[k]: v for k, v in preset['goal_tolerances'].items()}

                    edit_query.text = ', '.join([f'{k}: {v}' for k, v in self.asr.goal.items()])
                    edit_init.text = ', '.join([f'{k}: {v}' for k, v in self.asr.init.items()])
                    self.wnd_search.dolayout()

                def clear_goal(*_):
                    # remove all goal state specifications

                    children = [c for c in comp_goalsettings.children]
                    for c in children:
                        c.dispose()
                    btn_add_queryvar.enabled = True
                    btn_add_initvar.enabled = True
                    self.wnd_search.dolayout()

                def clear_init(*_):
                    # remove all init state specifications

                    children = [c for c in comp_initsettings.children]
                    for c in children:
                        c.dispose()
                    btn_add_queryvar.enabled = True
                    btn_add_initvar.enabled = True
                    self.wnd_search.dolayout()

                # ==================================================================

                btn_add_queryvar.on_select += add_goalvar_row()
                btn_add_initvar.on_select += add_initvar_row
                btn_clear_vars.on_select += clear_goal
                btn_clear_initvars.on_select += clear_init
                btn_clear_vars.on_select += updatequery
                combo_presets.on_select += loadpreset
                btn_execute_query.on_select += search

            self.wnd_search.show()

        def query_model_dialog(*_) -> None:

            # open query window which allows to select model to query, specify query variables and select variables
            # to be plotted
            if self.wnd_query_model is not None and not self.wnd_query_model.disposed:
                # make window visible again and put focus on it
                self.wnd_query_model.visible = True
                self.wnd_query_model.focus()
            else:
                self.wnd_query_model = Shell(parent=self._shell, title='BayRoB Query',
                                             border=True, btnclose=True, btnmin=True,
                                             resize=True, modal=False, titlebar=True)
                self.wnd_query_model.on_resize += self.wnd_query_model.dolayout

                w = min(800., 0.8 * session.runtime.display.width.value)
                h = min(600., 0.7 * session.runtime.display.height.value)
                self.wnd_query_model.bounds = self._shell.width.value/2 - w/2, self._shell.height.value/2 - h/2, w, h
                comp = Composite(self.wnd_query_model.content, hscroll=True, vscroll=True)
                comp.layout = RowLayout(halign='fill', valign='fill', flexrows={5: 1, 10: 1})

                # ==================================================================

                # combo to select tree model
                Label(comp, text='Select model', valign='fill', halign='fill')
                combo_models = Combo(comp, editable=False, items=[], halign='fill')
                Separator(comp, horizontal=True, halign='fill')

                # ==================================================================

                # multiple combos to select variables from trees
                # contains rows of triples (-, combovariable, text value)
                Label(comp, text='Select query variable(s)', valign='fill', halign='fill')
                comp_varsettings = Composite(comp)
                comp_varsettings.layout = RowLayout(halign='fill', valign='fill', equalheights=True)

                # buttons to add new queryrow and remove entire query block
                Label(comp, text='', valign='fill', halign='fill')
                comp2 = Composite(comp)
                comp2.layout = ColumnLayout(halign='left', valign='fill')
                btn_add_queryvar = Button(comp2, '+')
                btn_clear_vars = Button(comp2, 'clear query')
                btn_add_queryvar.enabled = False
                edit_query = Label(comp2, text="", valign='center', halign='fill')
                Separator(comp, horizontal=True, halign='fill')

                # ==================================================================

                Label(comp, text='Plot settings', valign='fill', halign='fill')
                comp_varplot = Composite(comp)
                comp_varplot.layout = RowLayout(halign='fill', valign='fill', equalheights=True)

                # buttons to add new queryrow and remove entire query block
                Label(comp, text='', valign='fill', halign='fill')
                comp3 = Composite(comp)
                comp3.layout = ColumnLayout(halign='left', valign='fill')
                btn_add_plotvar = Button(comp3, '+')
                btn_add_plotvar.enabled = False
                btn_clear_plotvars = Button(comp3, 'clear plot vars')
                edit_plotvars = Label(comp3, text="", valign='center', halign='fill')

                # ==================================================================

                btn_execute_query = Button(comp, 'Query', valign='fill', halign='fill')

                # ==================================================================

                self.qo = Query()

                def add_queryvar_row(*_):
                    # query specification:
                    # add row containing dropdown box for variable selection (variables from selected model), value
                    # specification and button to remove entire row

                    btn_add_queryvar.enabled = True

                    comp_tmp = Composite(comp_varsettings)
                    comp_tmp.layout = ColumnLayout(halign='fill', valign='fill', flexcols=[0, 1])
                    combo_vars = Combo(comp_tmp, editable=False, items=self.qo.model.variables, minwidth=px(200), halign='fill', valign='fill')
                    lbl_vals = Edit(comp_tmp, message="", editable=True, minwidth=px(200), valign='fill', halign='fill')
                    btn_rem_queryvar = Button(comp_tmp, '-', valign='fill', halign='fill')

                    def add_queryvar(*_) -> None:
                        # add variable represented by row to query specification

                        self.qo.query[combo_vars.selection] = parseval(
                            lbl_vals.text,
                            var=combo_vars.selection
                        )
                        updatequery()

                    def rem_queryvar(*_) -> None:
                        # remove variable represented by row from query specification

                        if combo_vars.selection in self.qo.query and self.qo.query[combo_vars.selection] == lbl_vals.text:
                            del self.qo.query[combo_vars.selection]
                        comp_tmp.dispose()
                        updatequery()

                    def update_suggestions(*_) -> None:
                        # add message with suggestions for possible values depending on selected variable

                        lbl_vals.message = suggestions(combo_vars.selection)
                        self.wnd_query_model.dolayout()

                    btn_rem_queryvar.on_select += rem_queryvar
                    combo_vars.on_select += update_suggestions
                    lbl_vals.on_modify += add_queryvar
                    self.wnd_query_model.dolayout()

                def add_plotvar_row(*_) -> None:
                    # plot specification:
                    # add row containing dropdown box for variable selection (variables from selected model) and
                    # button to remove row

                    btn_add_plotvar.enabled = True

                    comp_tmp = Composite(comp_varplot)
                    comp_tmp.layout = ColumnLayout(halign='fill', valign='fill', flexcols=[0])
                    combo_vars = Combo(comp_tmp, editable=False, items=self.presets('plotvars')[self.qo.modelname], minwidth=px(200), halign='fill', valign='fill')
                    btn_rem_var = Button(comp_tmp, '-', valign='fill', halign='fill')

                    def add_plotvar(*_) -> None:
                        # add variable represented by row to list of plots

                        self.qo.plotvars.append(combo_vars.selection)
                        updateplot()

                    def rem_plotvar(*_) -> None:
                        # remove variable represented by row from list of plots

                        if combo_vars.selection in self.qo.plotvars:
                            self.qo.plotvars.remove(combo_vars.selection)
                        comp_tmp.dispose()
                        updateplot()
                        self.wnd_query_model.dolayout()

                    btn_rem_var.on_select += rem_plotvar
                    combo_vars.on_select += add_plotvar
                    self.wnd_query_model.dolayout()

                def updatequery(*_):
                    # update the text summary of query so far

                    self.qo.querystr = build_constraints({k.name: v for k,v in self.qo.query.items()})
                    edit_query.text = self.qo.querystr
                    self.wnd_query_model.dolayout()

                def updateplot(*_) -> None:
                    # update the text summary variables to plot

                    edit_plotvars.text = ', '.join([str(x) for x in self.qo.plotvars])
                    self.wnd_query_model.dolayout()

                def clear_query(*_):
                    # remove all query specifications

                    children = [c for c in comp_varsettings.children]
                    for c in children:
                        if c.children[0].selection in self.qo.query:
                            del self.qo.query[c.children[0].selection]
                        c.dispose()
                    btn_add_queryvar.enabled = True
                    btn_add_plotvar.enabled = True
                    self.qo.model = combo_models.selection
                    self.qo.modelname = list(combo_models.items.keys())[combo_models.selidx]
                    self.wnd_query_model.dolayout()

                def clear_plot(*_):
                    # remove all variables from plot list

                    self.qo.plotvars = []
                    children = [c for c in comp_varplot.children]
                    for c in children:
                        c.dispose()
                    btn_add_queryvar.enabled = True
                    btn_add_plotvar.enabled = True
                    self.qo.model = combo_models.selection
                    self.qo.modelname = list(combo_models.items.keys())[combo_models.selidx]
                    updateplot()
                    self.wnd_query_model.dolayout()

                # ==================================================================

                combo_models.on_select += clear_query
                combo_models.on_select += clear_plot
                combo_models.items = self.bayrob.allmodels()
                btn_add_queryvar.on_select += add_queryvar_row
                btn_add_plotvar.on_select += add_plotvar_row
                btn_clear_vars.on_select += clear_query
                btn_clear_vars.on_select += updatequery
                btn_clear_plotvars.on_select += clear_plot
                btn_clear_plotvars.on_select += updatequery
                btn_execute_query.on_select += query_jpt

            self.wnd_query_model.show()

        #################
        # SET LISTENERS #
        #################
        btn_query_model.on_select += query_model_dialog
        btn_search.on_select += search_dialog
        tabfldr_body.selected = 0

        self._shell.show()

    # = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
    # MOBILE VERSION
    # = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
    # def mobile(self, **kwargs) -> None:
    #     self._shell = Shell(maximized=True, titlebar=False)
    #     self._shell.bg = Color('transp')
    #     self._shell.on_resize += self._shell.dolayout
    #
    #     comp_mainframe = Composite(self._shell.content)
    #     comp_mainframe.layout = RowLayout(halign='fill', valign='fill', flexrows={1: 1}, vspace=0)
    #
    #     # * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    #     # HEADER
    #     # * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    #     comp_header = Composite(comp_mainframe)
    #     comp_header.layout = ColumnLayout(halign='fill', flexcols={1: 0.2, 4: 0.2}, padding=Pixels(0))
    #     comp_header.css = 'navbar'
    #     comp_header.bgimg = Image(res('static/images/dark-metal-texture_rot.png'))
    #
    #     # LOGOS #
    #     h = 35
    #     _logo = Image(res('static/images/logo.png')).resize(height=px(int(h)))
    #     h = _logo.height
    #     logo = Label(comp_header, padding=Pixels(0), img=_logo, valign='top')
    #     logo.bg = Color('transp')
    #     Label(comp_header, padding=Pixels(0))
    #     ailogo = Label(comp_header, img=Image(res('static/images/ai_logo_white.png')).resize(height=Pixels(.9 * h)), valign='center', halign='center')
    #     ailogo.bg = Color('transp')
    #     Label(comp_header, padding=Pixels(0))
    #
    #     # MENU #
    #     menulabel = Label(comp_header, img=Image(res('static/images/menu.png')).resize(height=Pixels(.9 * h)), valign='center', halign='right', padding=Pixels(5))
    #     menulabel.layout.minheight = Pixels(.6 * h)
    #     menulabel.bg = 'transp'
    #
    #     # * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    #     # BODY
    #     # * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    #     comp_body = Composite(comp_mainframe, border=True)
    #     comp_body.layout = StackLayout(halign='fill', valign='fill')
    #     comp_body.bg = Color('white')
    #
    #     lbl_status = Label(comp_mainframe, text='', valign='fill', halign='fill')
    #
    #     # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    #
    #     # HOME PAGE #
    #     comp_home = Composite(comp_body)
    #     comp_home.layout = RowLayout(flexrows=0, halign='fill', valign='fill')
    #     comp_home.bg = Color('white')
    #     comp_home.visible = True
    #
    #     comp = Composite(comp_home, hscroll=True, vscroll=True)
    #     comp.layout = RowLayout(halign='fill', valign='fill', flexrows=0)
    #
    #     comp_profile = Composite(comp)
    #     comp_profile.layout = ColumnLayout(halign='fill', valign='fill', flexcols=0)
    #
    #     comp_features = Composite(comp_profile)
    #     comp_features.layout = RowLayout(halign='fill', valign='fill', flexrows=0)
    #     feature_table = Table(comp_features, halign='fill', valign='fill', headervisible=True, colsmoveable=True, check=False)
    #     expdata = dict([(list(d.keys())[-1], d[list(d.keys())[-1]]) for d in json.load(open(os.path.join(locs.examples, 'paperexample', 'exampledata.json'), 'r'))])
    #     combo_experiments = Combo(comp_features, editable=False, items=expdata, minwidth=self._shell.width.value/2, halign='fill', valign='fill')
    #
    #     def sort_by_feat(*_):
    #         feature_table.items = sorted(feature_table.items, key=lambda item: item.texts[0],
    #                                      reverse=feature_table.sortedby[1] == 'down')
    #
    #     def sort_by_unit(*_):
    #         feature_table.items = sorted(feature_table.items, key=lambda item: item.texts[1],
    #                                      reverse=feature_table.sortedby[1] == 'down')
    #
    #     col_feature = feature_table.addcol('Feature', sortable=True, width=100)
    #     col_feature.on_select += sort_by_feat
    #     col_unit = feature_table.addcol('Unit', sortable=True, width=100)
    #     col_unit.on_select += sort_by_unit
    #     col_min = feature_table.addcol('Min', sortable=False, width=100)
    #     col_max = feature_table.addcol('Max', sortable=False, width=100)
    #
    #     m = Menu(feature_table, popup=True)
    #     rem = MenuItem(m, 'Remove feature from requirement profile...')
    #     insert = MenuItem(m, 'Add feature to requirement profile...')
    #
    #     def insertitem(*_):
    #         # inserts currently selected table item as propety axis in requirement profile.
    #         # Values taken from previously loaded experimental data.
    #         featurename = feature_table.selection.texts[0]
    #         if featurename not in [axis.name for axis in radar_req.axes]:
    #             datamin = float(self.descrs.get(featurename, {}).get('min', 0))
    #             datamax = float(self.descrs.get(featurename, {}).get('max', 1))
    #
    #             radar_req.addaxis(
    #                 featurename,
    #                 minval=.8 * datamin if datamin > 0 else 1.2 * datamin,
    #                 maxval=1.2 * datamax if datamax > 0 else .8 * datamax,
    #                 unit=self.descrs.get(featurename, {}).get('unit', ''),
    #                 intervalmin=datamin + abs(datamax - datamin) / 2,
    #                 intervalmax=datamax - abs(datamax - datamin) / 2
    #             )
    #
    #     def remitem(*_):
    #         # removes currently selected table item (=property axis) from requirement profile
    #         featurename = feature_table.selection.texts[0]
    #         radar_req.remaxisbyname(featurename)
    #
    #     # TODO temporary preset loading and threshold entering, prettify or remove!
    #     combo_presets = Combo(comp_features, items=[], halign='fill', valign='fill')
    #
    #     # grp_strategy = Group(comp_features, text='Strategy')
    #     # grp_strategy.layout = ColumnLayout(halign='fill', valign='fill', equalwidths=True)
    #     #
    #     # opt_bfs = Option(grp_strategy, text='BFS')
    #     # opt_dfs = Option(grp_strategy, text='DFS')
    #     # opt_bfs.checked = True
    #
    #     lbl_threshold = Edit(comp_features, text="0.2", message='Threshold', editable=True, valign='center', halign='fill')
    #
    #     insert.on_select += insertitem
    #     rem.on_select += remitem
    #     feature_table.menu = m
    #
    #     def loadexperiment(*_) -> None:
    #
    #         # deletes previously loaded items
    #         feature_table.items = []
    #
    #         for feature in self.descrs:
    #             feature_table.additem([feature,
    #                                    self.descrs.get(feature, {}).get('unit', ''),
    #                                    self.descrs.get(feature, {}).get('min', ''),
    #                                    self.descrs.get(feature, {}).get('max', '')])
    #         self._shell.dolayout()
    #
    #         # update options for preset toggle button and load preset
    #         self._sel = list(combo_experiments.items)[combo_experiments.selidx]
    #         combo_presets.items = list(combo_experiments.selection.get('presets', {}).keys())
    #
    #     def loadpreset(*_) -> None:
    #         self._sel = list(combo_experiments.items)[combo_experiments.selidx]
    #
    #         # delete possibly existing axes from previous experiment
    #         radar_req.clear()
    #         radar_req.layout.minwidth = self._shell.bounds[2] - 8
    #         radar_req.layout.minheight = self._shell.bounds[3]*0.7
    #
    #         p = combo_experiments.selection['presets'].get(combo_presets.selection, None)
    #
    #         lbl_status.text = 'Currently loaded preset: {}'.format(combo_presets.selection)
    #         logger.info('Currently loaded preset', combo_presets.selection, p)
    #
    #         if p is not None:
    #             for feat in p.keys():
    #                 datamin = float(self.descrs.get(feat, {}).get('min', 0) or 0)
    #                 datamax = float(self.descrs.get(feat, {}).get('max', 1) or 1)
    #
    #                 radar_req.addaxis(
    #                     feat,
    #                     minval=.8 * datamin if datamin > 0 else 1.2 * datamin,
    #                     maxval=1.2 * datamax if datamax > 0 else .8 * datamax,
    #                     unit=self.descrs.get(feat, {}).get('unit', ''),
    #                     intervalmin=datamin + abs(datamax - datamin) / 2 if p[feat] is None else p[feat][0],
    #                     intervalmax=datamax - abs(datamax - datamin) / 2 if p[feat] is None else p[feat][1]
    #                 )
    #         switchpage(None, comp_definereq)
    #         self._shell.dolayout(pack=True)
    #
    #     combo_experiments.on_select += loadexperiment
    #     combo_presets.on_select += loadpreset
    #
    #     # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    #
    #     # DEFINE REQUIREMENT PROFILE PAGE #
    #     comp_definereq = Composite(comp_body)
    #     comp_definereq.layout = RowLayout(halign='fill', valign='fill', flexrows=0)
    #     comp_definereq.visible = False
    #
    #     comp_radar = ScrolledComposite(comp_definereq, valign='fill', halign='fill', vscroll=True, hscroll=True)
    #
    #     radar_req = Radar(comp_radar.content, legendtext='', halign='fill', valign='fill', minwidth=self._shell.bounds[2], minheight=self._shell.bounds[3]*0.7)
    #
    #     # LISTENER FUNCTIONS
    #     def setinterval(axis) -> None:
    #         answer = ask_input(self._shell, 'Enter Interval for axis "{}"'.format(axis), message='[-2,3]')
    #         if answer is not None:
    #             try:
    #                 interval = ContinuousSet.fromstring(answer)
    #                 radar_req.interval(axis, minval=interval.lower, maxval=interval.upper)
    #             except:
    #                 msg_err(self._shell, 'Error', 'Unable to set Interval {}. Please use a valid notation (e.g. [-2,3])'.format(answer))
    #
    #     def remaxis(axis) -> None:
    #         radar_req.remaxisbyname(axis)
    #         lbl_status.text = 'Axis "{0}" was removed and will hence be ignored.'.format(axis)
    #
    #     def open_menu(axis):
    #         # show menu for right click on axis in requirement profile radar
    #
    #         # AXIS MENU #
    #         menuentries = OrderedDict([
    #             ('Set interval', setinterval),
    #             ('Remove axis "{}"'.format(axis), remaxis)
    #         ])
    #
    #         answer, callback = options_list(self._shell, menuentries)
    #         callback(axis)
    #
    #     lbl_req_changes = Label(comp_definereq, text='<b>Requirement changes:</b>', markup=True, halign='fill', valign='fill')
    #     lbl_req_changes.visible = False
    #     btn_query = Button(comp_definereq, 'Query')
    #
    #     def sel(*kwargs) -> None:
    #         # listener function for interaction with requirement profile radar chart.
    #         # Handles feedback for user
    #         d = kwargs[0].args[0]
    #         stat = ''
    #         if d.get('type') == 'circle':
    #             stat = 'The {1[name]} value for the alloy {0} has been changed to {1[value]}!'.format(d['dataset'], d['data'])
    #         elif d.get('type') in ['mininterval', 'rs_miniv']:
    #             stat = 'The lower bound for the property "{0[name]}" was set to {1}!'.format(d['dataset'], d['data'])
    #         elif d.get('type') in ['maxinterval', 'rs_maxiv']:
    #             stat = 'The upper bound for the property "{0[name]}" was set to {1}!'.format(d['dataset'], d['data'])
    #         elif d.get('type') == 'axis':
    #             if kwargs[0].button == 'right':
    #                 switchpage(d['axis'])
    #                 return
    #         else:
    #             stat = 'invalid datatype {}'.format(d.get('type'))
    #         lbl_status.text = stat
    #
    #     def update(self) -> None:
    #         # initialize radar chart containing candidate datasets
    #         self.candidates = self.bayrob.hypotheses
    #         radar_candidates = Radar(comp_res.content, legendtext='Hypotheses', halign='fill', valign='fill', minwidth=self._shell.bounds[2], minheight=self._shell.bounds[3]*0.7)
    #
    #         # create empty radar chart from requirement profile
    #         for axis in radar_req.axes:
    #             radar_candidates.addaxis(axis.name,
    #                                      minval=axis.minval,
    #                                      maxval=axis.maxval,
    #                                      unit=axis.unit,
    #                                      intervalmin=axis.intervalmin,
    #                                      intervalmax=axis.intervalmax)
    #
    #         data = {}
    #         for i, hyp in enumerate(self.candidates):
    #             pathvals = hyp.result
    #             values = [pathvals.get(a.name, 0) for a in radar_candidates.axes]
    #             data.update({hyp.id: values})
    #             table_candidates.additem([hyp.id, str(hyp.performance)])
    #
    #         # sort results in table descending by probability
    #         sort_by_sim(down=True)
    #
    #         # data maps example name (=material) to (sorted) list of values for the radar chart axes
    #         radar_candidates.setdata(data)
    #         lbl_status.text = '...done! Found {} candidates.'.format(len(self.candidates))
    #
    #         switchpage(None, comp_candidates)
    #
    #         self._shell.dolayout()
    #
    #     def showproc(*_) -> None:
    #         if self.bayrob.resulttree:
    #             cnamefull = table_candidates.selection.texts[0]
    #
    #             # self.candidates is a list of [confs, RegressionTree nodes (path from leaf to src)]
    #             # construct data for tree
    #             generate_nodes()
    #             data = nodedict(self.bayrob.resulttree.src, cnamefull)
    #
    #             tree.setdata(data)
    #
    #             switchpage(None, comp_tree)
    #
    #     def generate_nodes() -> None:
    #         parentnode = ResTree.Node(None, nodetext='Start', printnode=False)
    #         parentnode.isroot = True
    #         parentnode.parameters = self.bayrob.query
    #         self.bayrob.resulttree.src = parentnode
    #
    #         hyps = self.bayrob.hypotheses.copy()
    #         generate_nodes_rec(self.bayrob.resulttree.src, hyps, 0)
    #
    #     def generate_nodes_rec(parent, hypotheses, d) -> None:
    #         for h in hypotheses:
    #             if d < len(h.steps):
    #                 step = h.steps[d]
    #
    #                 # create node if not exists yet
    #                 n_ = ResTree.Node(parent, printnode=False)
    #                 n_.nodetext = 'H_' + '.'.join([str(el) for el in h.identifiers[:d+1]])
    #                 n_.edgetext = step.name
    #                 n_.result = step.value.copy()
    #                 n_.parameters = step.path.copy()
    #                 n_.confs = h.performance
    #
    #                 # leaf nodes show confs and overall result instead of step result
    #                 if d == len(h.steps)-1:
    #                     n_.nodetext = h.id
    #                     n_.result = h.result.copy()
    #                     n_.printnode = True
    #
    #                 # add node
    #                 if n_ not in parent.children:
    #                     parent.children.append(n_)
    #
    #         # recursive call
    #         for n in parent.children:
    #             generate_nodes_rec(n, [hyp for hyp in hypotheses if 'H_' + '.'.join([str(el) for el in hyp.identifiers[:d+1]]) == n.nodetext and d+1 < len(hyp.steps)], d+1)
    #
    #     def nodedict(node, hypname) -> dict:
    #         d = {
    #             "edgetext": str(node.edgetext),
    #             "edgetooltip": str(node.edgetttext),
    #             "name": str(node.nodetext),
    #             "tooltip": str(node.nodetttext),
    #             "type": "highlight" if hypname.startswith(node.nodetext) else None,
    #             "showname": node.printnode,
    #             "showedge": True,
    #             "children": []
    #             }
    #         if node.children:
    #            d.update({'children': [nodedict(c, hypname) for c in node.children]})
    #         return d
    #
    #     @self.checkthread
    #     def query(*_) -> None:
    #         self.bayrob.pushsession.start()
    #
    #         try:
    #             threshold = float(lbl_threshold.text)
    #         except:
    #             threshold = 0.0
    #
    #         # query = dict([(a.name, Interval(a.intervalmin, a.intervalmax)) for a in radar_req.axes])
    #         query = dict([(a.name, ContinuousSet(a.intervalmin, a.intervalmax)) for a in radar_req.axes])
    #
    #         lbl_status.text = 'Querying: threshold={}, params= {}'.format(threshold, ', '.join(['{}: {}'.format(a.name, str(ContinuousSet(a.intervalmin, a.intervalmax))) for a in radar_req.axes]))
    #         logger.info('Querying', {k: str(v) for k, v in query.items()}, threshold, ', '.join(['{}: {}'.format(a.name, str(ContinuousSet(a.intervalmin, a.intervalmax))) for a in radar_req.axes]))
    #
    #         for ti in [x for x in table_candidates.items]:
    #             table_candidates.rmitem(ti)
    #
    #         for c in comp_res.content.children:
    #             c.dispose()
    #
    #         # use bayrob reasoner to query system
    #         self.bayrob.query = query
    #         self.bayrob.threshold = threshold
    #         self.bayrob.models = combo_experiments.selection['trees']
    #         self.bayrob.callback = update
    #         self.bayrob.start()
    #
    #     radar_req.on_select += sel
    #     btn_query.on_select += query
    #
    #     # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    #
    #     # CANDIDATES PAGE #
    #     comp_candidates = Composite(comp_body)
    #     comp_candidates.layout = RowLayout(flexrows=0, halign='fill', valign='fill')
    #     comp_candidates.bg = Color('white')
    #     comp_candidates.visible = False
    #
    #     table_candidates = Table(comp_candidates, halign='fill', valign='fill', headervisible=True,
    #                              colsmoveable=True, check=False)
    #
    #     def sort_by_sim(down=None) -> None:
    #         if isinstance(down, bool):
    #             table_candidates.items = sorted(table_candidates.items, key=lambda item: float(item.texts[1]), reverse=down)
    #         else:
    #             table_candidates.items = sorted(table_candidates.items, key=lambda item: float(item.texts[1]), reverse=table_candidates.sortedby[1] == 'down')
    #
    #     def sort_by_cand(*_) -> None:
    #         table_candidates.items = sorted(table_candidates.items, key=lambda item: str(item.texts[0]), reverse=table_candidates.sortedby[1] == 'down')
    #
    #     col_candidatename = table_candidates.addcol('Candidate', sortable=True, width=100)
    #     col_candidatename.on_select += sort_by_cand
    #
    #     col_sim = table_candidates.addcol('Probability', sortable=True, width=200)
    #     col_sim.on_select += sort_by_sim
    #
    #     tcm = Menu(table_candidates, popup=True)
    #     mitem_showproc = MenuItem(tcm, 'Show process history of candidate')
    #     table_candidates.menu = tcm
    #
    #     table_candidates.on_dblclick += showproc
    #
    #     mitem_showproc.on_select += showproc
    #
    #     # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    #
    #     # RESULTS PAGE
    #     comp_res = ScrolledComposite(comp_body, valign='fill', halign='fill', vscroll=True, hscroll=True)
    #
    #     radar_candidates = Radar(comp_res.content, legendtext='', halign='fill', valign='fill', minwidth=self._shell.bounds[2], minheight=self._shell.bounds[3] * 0.7)
    #     comp_res.visible = False
    #
    #     # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    #
    #     # TREE PAGE
    #     comp_tree = Composite(comp_body)
    #     comp_tree.layout = RowLayout(halign='fill', valign='fill', flexrows=0)
    #
    #     tree = RadialTree(comp_tree, css=[res('static/css/charval.css')], halign='fill', valign='fill')
    #
    #     comp_tree.visible = False
    #
    #     # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    #
    #     # DOCUMENTATION PAGE #
    #     comp_docs = Composite(comp_body)
    #     comp_docs.layout = RowLayout(halign='fill', valign='fill', flexrows=0)
    #
    #     self.setupdoku()
    #     Browser(comp_docs, url=config.get('upload', 'dokuloc', fallback=''.join(['http://', session.host, session.location, session.runtime.mngr.resources.get('users.html').location])), halign='fill', valign='fill')
    #     comp_docs.visible = False
    #
    #     # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    #
    #     # MAIN MENU #
    #     menuentries = OrderedDict([
    #         ('Home', comp_home),
    #         ('Define Requirement Profile', comp_definereq),
    #         ('Candidates', comp_candidates),
    #         ('Results', comp_res),
    #         ('Tree', comp_tree),
    #         ('Documentation', comp_docs)
    #     ])
    #
    #     # LISTENER FUNCTIONS
    #     def switchpage(_, widget=None) -> None:
    #         if widget is None:
    #             _, widget = options_list(self._shell, menuentries)
    #
    #         # make all widgets invisible and update the layers
    #         for c in comp_body.children:
    #             c.visible = False
    #
    #         # then get the one selected into the foreground
    #         logger.debug('Moving widget to foreground', widget.id)
    #         widget.visible = True
    #
    #     menulabel.on_mousedown += switchpage
    #
    #     # load initial preset
    #     combo_experiments.selection = "PaperExample2"
    #     # combo_presets.selection = 'preset3'
    #     loadexperiment()
    #
    #     self._shell.show()
    #
    def empty(self, **kwargs) -> None:
        self._shell = Shell(maximized=True, titlebar=False)
        self._shell.bg = Color('transp')
        self._shell.on_resize += self._shell.dolayout

        comp_mainframe = Composite(self._shell.content)
        comp_mainframe.layout = CellLayout(halign='fill', valign='fill')
        Label(comp_mainframe, "I am a placeholder")

        self._shell.show()


def main(ip='127.0.0.1', port=5008) -> None:

    pyrap.register_app(clazz=BayRoBWeb,
                       path='bayrob',
                       name='BayRoB',
                       entrypoints={'desktop': BayRoBWeb.desktop,
                                    # 'mobile': BayRoBWeb.mobile,
                                    'empty': BayRoBWeb.empty,
                                    },
                       setup=BayRoBWeb.setup,
                       theme=res('static/css/default.css'),
                       default=lambda: 'mobile' if 'mobile' in pyrap.session.client.useragent.lower() else 'desktop',
                       icon=res('static/images/ic_launcher/play_store_512.png')
                       )
    pyrap.run(bindip=ip, port=port)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='BayRoBWeb.')
    parser.add_argument('-p', '--port', type=int, default=5005, help='specify port to run the app on', required=False)
    parser.add_argument('-i', '--ip', type=str, default='127.0.0.1', help='specify port to run the app on', required=False)
    parser.add_argument("-v", "--verbose", dest="verbose", default='debug', type=str, action="store", help="Set verbosity level {debug,info,warning,error,critical}. Default is info.")
    args = parser.parse_args()

    init_loggers(level=args.verbose)
    main(ip='0.0.0.0' if config.getboolean('bayrob', 'public', fallback=False) else args.ip, port=args.port)
